-- | Java test code generation codec for JUnit-based generation tests

module Hydra.Ext.Staging.Java.TestCodec (
  javaTestGenerator,
  generateJavaGenerationTests,
) where

import Hydra.Kernel hiding (map)
import Hydra.Testing
import Hydra.Coders (LanguageName(..))
import Hydra.Staging.Testing.Generation.Transform (collectTestCases)
import Hydra.Staging.Testing.Generation.Generate (TestGenerator(..), createTestGroupLookup, generateGenerationTestSuite)
import Hydra.Ext.Java.Coder (encodeTerm)
import Hydra.Ext.Java.Helpers (JavaEnvironment(..), Aliases(..))
import Hydra.Ext.Java.Utils (importAliasesForModule)
import Hydra.Ext.Java.Serde (writeExpression)
import Hydra.Serialization (printExpr, parenthesize)
import qualified Hydra.Ext.Java.Syntax as Java
import qualified Hydra.Names as Names
import qualified Hydra.Util as Util
import qualified Hydra.Formatting as Formatting
import qualified Hydra.Lib.Strings as Strings
import qualified Hydra.Lib.Lists as Lists
import qualified Hydra.Schemas as Schemas
import Hydra.Typing (TypeContext(..), InferenceContext(..), InferenceResult(..))
import qualified Hydra.Inference as Inference

import qualified Data.Map as M
import qualified Data.List as L
import qualified Data.Maybe as Y
import qualified Data.Set as S
import Data.Char (toLower, toUpper, isAlphaNum, isUpper)
import qualified System.FilePath as FP


-- | Convert a Hydra term to a Java expression string
-- Takes a pre-built TypeContext to avoid rebuilding it for every term
termToJava :: TypeContext -> Term -> Flow Graph String
termToJava tcontext term = do
  let jenv = JavaEnvironment {
        javaEnvironmentAliases = emptyAliases,
        javaEnvironmentTypeContext = tcontext
      }
  jexpr <- encodeTerm jenv term
  return $ printExpr $ parenthesize $ writeExpression jexpr
  where
    emptyAliases = Aliases {
      aliasesCurrentNamespace = Namespace "test",
      aliasesPackages = M.empty,
      aliasesBranchVars = S.empty,
      aliasesRecursiveVars = S.empty,
      aliasesInScopeTypeParams = S.empty,
      aliasesPolymorphicLocals = S.empty,
      aliasesInScopeJavaVars = S.empty,
      aliasesVarRenames = M.empty,
      aliasesLambdaVars = S.empty,
      aliasesTypeVarSubst = M.empty,
      aliasesTrustedTypeVars = S.empty,
      aliasesMethodCodomain = Nothing,
      aliasesThunkedVars = S.empty
    }

-- | Convert a Hydra type to a Java type expression string
typeToJava :: TypeContext -> Type -> Flow Graph String
typeToJava _ typ = do
  -- For now, return a placeholder since type encoding isn't the main focus
  return "Object"

-- | Create a Java TestCodec
javaTestCodec :: TypeContext -> TestCodec
javaTestCodec tcontext = TestCodec {
    testCodecLanguage = LanguageName "java",
    testCodecFileExtension = FileExtension "java",
    testCodecEncodeTerm = termToJava tcontext,
    testCodecEncodeType = typeToJava tcontext,
    testCodecFormatTestName = formatJavaTestName,
    testCodecFormatModuleName = namespaceToJavaClassName,
    testCodecTestCaseTemplate = javaTestCaseTemplate,
    testCodecTestGroupTemplate = javaTestGroupTemplate,
    testCodecModuleTemplate = javaModuleTemplate,
    testCodecImportTemplate = javaImportTemplate,
    testCodecFindImports = \_ -> findJavaImports}

-- | Format a test name for Java (camelCase method name)
-- Preserves numbers and handles special characters to maintain uniqueness
formatJavaTestName :: String -> String
formatJavaTestName name = "test" ++ toCamelCase (preprocessName name)
  where
    -- Preprocess: convert special chars to words to preserve uniqueness
    preprocessName s = concatMap charToWord s
    charToWord c
      | c == '-' = " Neg"  -- Negative sign
      | c == '.' = "Dot"   -- Decimal point
      | c == '+' = " Plus"
      | c == '/' = " Div"
      | c == '*' = " Mul"
      | c == '#' = " Num"
      | otherwise = [c]
    toCamelCase s = concatMap capitalize $ words $ map toSnake s
    toSnake c
      | isAlphaNum c = c
      | otherwise = ' '
    capitalize [] = []
    capitalize (c:cs) = toUpper c : map toLower cs

-- Templates for Java test generation (JUnit style)
javaTestCaseTemplate :: String
javaTestCaseTemplate = unlines [
  "    @Test",
  "    public void {name}() {",
  "        assertEquals({output}, {input});",
  "    }"]

javaTestGroupTemplate :: String
javaTestGroupTemplate = "// {groupName}"

javaModuleTemplate :: String
javaModuleTemplate = unlines [
  "// " ++ warningAutoGeneratedFile,
  "",
  "package {package};",
  "",
  "{imports}",
  "",
  "public class {className} {",
  "    {testCases}",
  "}"]

javaImportTemplate :: String
javaImportTemplate = "import {namespace};"

-- | Find necessary imports for Java based on referenced namespaces
findJavaImports :: [String]
findJavaImports = [
  "import org.junit.jupiter.api.Test;",
  "import static org.junit.jupiter.api.Assertions.*;",
  "import java.util.*;"]

-- | Convert namespace to Java class name
namespaceToJavaClassName :: Namespace -> String
namespaceToJavaClassName (Namespace ns) =
  Strings.intercalate "." $ Lists.map Formatting.capitalize (Strings.splitOn "." ns)

-- | Generate test hierarchy for Java
-- The groupPath parameter accumulates parent group names to create unique test method names
generateJavaTestGroupHierarchy :: TypeContext -> TestCodec -> [String] -> TestGroup -> Flow Graph String
generateJavaTestGroupHierarchy tcontext codec groupPath testGroup = do
  -- Generate test cases at the current level
  testCaseLinesRaw <- mapM (generateJavaTestCase tcontext codec groupPath) (testGroupCases testGroup)
  let testCaseLines = concat testCaseLinesRaw
      testCasesStr = L.intercalate "\n\n" testCaseLines

  -- Generate sections for each subgroup, passing the subgroup name in the path
  subgroupStrs <- mapM generateSubgroupBlock (testGroupSubgroups testGroup)
  let subgroupsStr = L.intercalate "\n\n" subgroupStrs

  -- Combine test cases and subgroups
  return $ testCasesStr ++ (if null testCasesStr || null subgroupsStr then "" else "\n\n") ++ subgroupsStr
  where
    generateSubgroupBlock :: TestGroup -> Flow Graph String
    generateSubgroupBlock subgroup = do
      let groupName = testGroupName subgroup
      subgroupContent <- generateJavaTestGroupHierarchy tcontext codec (groupPath ++ [groupName]) subgroup
      let header = "    // " ++ groupName
      return $ header ++ "\n\n" ++ subgroupContent

-- | Assertion type for Java tests
data AssertionType
  = AssertEquals           -- Standard assertEquals
  | AssertArrayEquals      -- For byte[] comparison
  | AssertBigDecimalEquals -- For BigDecimal comparison using compareTo
  | AssertDoubleEquals     -- For double comparison with tolerance
  deriving (Eq, Show)

-- | Determine the assertion type based on the output term structure
getAssertionType :: Term -> AssertionType
getAssertionType term = case stripAnnotations term of
  TermLiteral (LiteralBinary _) -> AssertArrayEquals
  TermLiteral (LiteralFloat fv) -> case fv of
    FloatValueBigfloat _ -> AssertBigDecimalEquals
    FloatValueFloat64 _ -> AssertDoubleEquals
    FloatValueFloat32 _ -> AssertDoubleEquals
  _ -> AssertEquals
  where
    stripAnnotations (TermAnnotated (AnnotatedTerm t _)) = stripAnnotations t
    stripAnnotations t = t

-- | Generate the assertion code based on the assertion type
generateAssertion :: AssertionType -> String -> String -> [String]
generateAssertion assertType outputCode inputCode = case assertType of
  AssertEquals ->
    ["        assertEquals(",
     "            " ++ outputCode ++ ",",
     "            " ++ inputCode ++ ");"]
  AssertArrayEquals ->
    ["        assertArrayEquals(",
     "            " ++ outputCode ++ ",",
     "            " ++ inputCode ++ ");"]
  AssertBigDecimalEquals ->
    ["        assertEquals(0, (" ++ outputCode ++ ").compareTo(" ++ inputCode ++ "));"]
  AssertDoubleEquals ->
    ["        assertEquals(",
     "            " ++ outputCode ++ ",",
     "            " ++ inputCode ++ ",",
     "            1e-15);"]  -- Tolerance for floating-point comparison

-- | Generate a single test case for Java/JUnit
generateJavaTestCase :: TypeContext -> TestCodec -> [String] -> TestCaseWithMetadata -> Flow Graph [String]
generateJavaTestCase tcontext codec groupPath (TestCaseWithMetadata name tcase _ _) = case tcase of
  TestCaseDelegatedEvaluation (DelegatedEvaluationTestCase input output) -> do
    inputCode <- testCodecEncodeTerm codec input
    outputCode <- testCodecEncodeTerm codec output

    -- Include group path in test name to avoid collisions
    let fullName = if L.null groupPath
          then name
          else L.intercalate "_" (groupPath ++ [name])
        formattedName = testCodecFormatTestName codec fullName
        assertType = getAssertionType output
        assertionLines = generateAssertion assertType outputCode inputCode
    return $ [
      "    @Test",
      "    public void " ++ formattedName ++ "() {"] ++ assertionLines ++ ["    }"]

  _ -> return []  -- Skip non-delegated tests

-- | Generate test file using Java codec
generateTestFileWithJavaCodec :: TestCodec -> Module -> TestGroup -> TypeContext -> Flow Graph (FilePath, String)
generateTestFileWithJavaCodec codec testModule testGroup tcontext = do
  -- Generate test hierarchy
  testBody <- generateJavaTestGroupHierarchy tcontext codec [] testGroup

  -- Build the complete test module
  let testModuleContent = buildJavaTestModule codec testModule testGroup testBody

  -- Generate file path: namespace -> path
  let Namespace ns = moduleNamespace testModule
      parts = Strings.splitOn "." ns
      dirParts = L.init parts
      -- Add "Test" suffix to class name for JUnit convention
      className = Formatting.capitalize (L.last parts) ++ "Test"
      fileName = className ++ ".java"
      filePath = L.intercalate "/" dirParts ++ "/" ++ fileName

  return (filePath, testModuleContent)

-- | Build complete Java test module
buildJavaTestModule :: TestCodec -> Module -> TestGroup -> String -> String
buildJavaTestModule codec testModule testGroup testBody = header ++ testBody ++ "\n}\n"
  where
    Namespace ns = moduleNamespace testModule
    parts = Strings.splitOn "." ns
    packageName = L.intercalate "." (L.init parts)
    className = Formatting.capitalize (L.last parts) ++ "Test"
    groupName = testGroupName testGroup

    -- Standard imports for Java JUnit tests
    standardImports = [
      "import org.junit.jupiter.api.Test;",
      "import static org.junit.jupiter.api.Assertions.*;",
      "import java.util.*;",
      "import hydra.util.*;"]

    header = unlines [
        "// " ++ warningAutoGeneratedFile,
        "// " ++ groupName,
        "",
        "package " ++ packageName ++ ";",
        ""
      ] ++ L.intercalate "\n" standardImports ++ "\n\n" ++
      "public class " ++ className ++ " {\n\n"

-- | Generate Java test file for a test group
generateJavaTestFile :: Module -> TestGroup -> Flow Graph (FilePath, String)
generateJavaTestFile testModule testGroup = do
  -- Run type inference on all test terms to ensure lambdas have domain types
  -- and generic types have their type arguments filled in
  inferredTestGroup <- inferTestGroupTerms testGroup

  -- Build TypeContext for term encoding
  g <- getState
  tcontext <- Schemas.graphToTypeContext g

  -- Generate test file using the codec
  generateTestFileWithJavaCodec (javaTestCodec tcontext) testModule inferredTestGroup tcontext

-- | Run type inference on all terms in a TestGroup
-- This ensures that lambdas have their domain types filled in and
-- generic types (List, Maybe, Either, etc.) have their type arguments,
-- which is required by the Java coder.
inferTestGroupTerms :: TestGroup -> Flow Graph TestGroup
inferTestGroupTerms (TestGroup name desc subgroups cases) = do
  inferredSubgroups <- mapM inferTestGroupTerms subgroups
  inferredCases <- mapM inferTestCase cases
  return $ TestGroup name desc inferredSubgroups inferredCases

-- | Run type inference on the terms in a test case
inferTestCase :: TestCaseWithMetadata -> Flow Graph TestCaseWithMetadata
inferTestCase (TestCaseWithMetadata name tcase desc tags) = do
  inferredTcase <- case tcase of
    TestCaseDelegatedEvaluation (DelegatedEvaluationTestCase input output) -> do
      inferredInput <- inferTerm input
      inferredOutput <- inferTerm output
      return $ TestCaseDelegatedEvaluation $ DelegatedEvaluationTestCase inferredInput inferredOutput
    other -> return other
  return $ TestCaseWithMetadata name inferredTcase desc tags

-- | Run type inference on a single term
inferTerm :: Term -> Flow Graph Term
inferTerm term = do
  result <- Inference.inferInGraphContext term
  return $ inferenceResultTerm result

-- | Java-specific test generator
javaTestGenerator :: TestGenerator ()
javaTestGenerator = TestGenerator {
  testGenNamespacesForModule = \_ -> return $ Namespaces (Namespace "", ()) M.empty,
  testGenCreateCodec = \_ -> javaTestCodec emptyTypeContext,
  testGenGenerateTestFile = generateJavaTestFile,
  testGenAggregatorFile = Nothing  -- Could add a test suite aggregator later
}
  where
    emptyTypeContext = TypeContext M.empty M.empty S.empty S.empty S.empty emptyInferenceContext
    emptyInferenceContext = InferenceContext M.empty M.empty M.empty M.empty False

-- | Main entry point for generating Java generation tests
generateJavaGenerationTests :: FilePath -> [Module] -> (Namespace -> Maybe TestGroup) -> IO Bool
generateJavaGenerationTests = generateGenerationTestSuite javaTestGenerator
