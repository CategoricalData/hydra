definitions:
  - name: PredefString # See scala/Predef.scala
    type: string
  - name: ScalaSymbol # See scala/Symbol.scala
    type:
      record:
        - name: name
          type: string

### scala/meta/Trees.scala source below this line. Hydra type definitions inline ###
#package scala.meta
#
#import org.scalameta.invariants._
#import scala.meta.classifiers._
#import scala.meta.inputs._
#import scala.meta.tokens._
#import scala.meta.prettyprinters._
#import scala.meta.internal.trees._
#import scala.meta.internal.trees.Metadata.binaryCompatField
#@root trait Tree extends InternalTree { #@
  - name: Tree # Note: ignoring fields of Tree and InternalTree for now
    type:
      union:
        - name: ref
          type: Ref #@
        - name: stat
          type: Stat #@
        - name: type
          type: Type #@
        - name: bounds
          type: Type.Bounds #@
        - name: pat
          type: Pat #@
        - name: member
          type: Member #@
        - name: ctor
          type: Ctor #@
        - name: template
          type: Template #@
        - name: mod
          type: Mod #@
        - name: enumerator
          type: Enumerator #@
        - name: importer
          type: Importer #@
        - name: importee
          type: Importee #@
        - name: caseTree
          type: CaseTree #@
        - name: source
          type: Source #@
        - name: quasi
          type: Quasi #@
#  def parent: Option[Tree]
#  def children: List[Tree]
#
#  def pos: Position
#  def tokens(implicit dialect: Dialect): Tokens
#
#  final override def canEqual(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
#  final override def equals(that: Any): Boolean = this eq that.asInstanceOf[AnyRef]
#  final override def hashCode: Int = System.identityHashCode(this)
#  final override def toString = scala.meta.internal.prettyprinters.TreeToString(this)
#}
#
#object Tree extends InternalTreeXtensions { #@
#  implicit def classifiable[T <: Tree]: Classifiable[T] = null
#  implicit def showStructure[T <: Tree]: Structure[T] =
#    scala.meta.internal.prettyprinters.TreeStructure.apply[T]
#  implicit def showSyntax[T <: Tree](implicit dialect: Dialect): Syntax[T] =
#    scala.meta.internal.prettyprinters.TreeSyntax.apply[T](dialect)
#}
#
#@branch trait Ref extends Tree #@
  - name: Ref
    type:
      union:
        - name: name
          type: Name #@
        - name: init
          type: Init #@
#@branch trait Stat extends Tree #@
  - name: Stat
    type:
      union:
        - name: term
          type: Term #@
        - name: decl
          type: Decl #@
        - name: defn
          type: Defn #@
        - name: importExport
          type: ImportExportStat #@
#
#@branch trait Name extends Ref { def value: String } #@
  - name: Name
    type:
      union:
        - name: value
          type: string
        - name: anonymous
        - name: indeterminate
          type: PredefString
#object Name {
    innerTypes:
#  def apply(value: String): Name = if (value == "") Name.Anonymous() else Name.Indeterminate(value)
#  def unapply(name: Name): Option[String] = Some(name.value)
#  @ast class Anonymous() extends Name { #@
#    def value = ""
#    checkParent(ParentChecks.NameAnonymous)
#  }
#  @ast class Indeterminate(value: Predef.String @nonEmpty) extends Name #@
#}
#
#@branch trait Lit extends Term with Pat with Type { #@
  - name: Lit
    type:
      union:
#  def value: Any
#}
#object Lit {
#  def unapply(arg: Lit): Option[Any] = Some(arg.value)
#  @ast class Null() extends Lit { def value: Any = null } #@
        - name: "null"
#  @ast class Int(value: scala.Int) extends Lit #@
        - name: int
          type: integer
#  // NOTE: Lit.Double/Float are strings to work the same across JS/JVM. Example:
#  // 1.4f.toString == "1.399999976158142" // in JS
#  // 1.4f.toString == "1.4"               // in JVM
#  // See https://www.scala-js.org/doc/semantics.html#tostring-of-float-double-and-unit
#  @ast class Double(format: scala.Predef.String) extends Lit { val value = format.toDouble } #@
        - name: double
          type:
            float:
              precision:
                bits: 64
#  object Double { def apply(double: scala.Double): Double = Lit.Double(double.toString) }
#  @ast class Float(format: scala.Predef.String) extends Lit { val value = format.toFloat } #@
        - name: float
          type: float
#  object Float { def apply(float: scala.Float): Float = Lit.Float(float.toString) }
#  @ast class Byte(value: scala.Byte) extends Lit #@
        - name: byte
          type:
            integer:
              precision:
                bits: 8
#  @ast class Short(value: scala.Short) extends Lit #@
        - name: short
          type:
            integer:
              precision:
                bits: 16
#  @ast class Char(value: scala.Char) extends Lit #@
        - name: char
          type:
            integer:
              signed: false
              precision:
                bits: 16
#  @ast class Long(value: scala.Long) extends Lit #@
        - name: long
          type:
            integer:
              precision:
                bits: 64
#  @ast class Boolean(value: scala.Boolean) extends Lit #@
        - name: boolean
          type: boolean
#  @ast class Unit() extends Lit { def value: Any = () } #@
        - name: unit
#  @ast class String(value: scala.Predef.String) extends Lit #@
        - name: string
          type: string
#  @ast class Symbol(value: scala.Symbol) extends Lit #@
        - name: symbol
          type: ScalaSymbol
#}
#
#@branch trait Term extends Stat #@
  - name: Term
    type:
      union:
        - name: lit
          type: Lit #@
        - name: ref
          type: Term.Ref #@
        - name: interpolate
          type: Term.Interpolate #@
        - name: xml
          type: Term.Xml #@
        - name: apply
          type: Term.Apply #@
        - name: applyUsing
          type: Term.ApplyUsing #@
        - name: applyType
          type: Term.ApplyType #@
        - name: applyInfix
          type: Term.ApplyInfix #@
        - name: assign
          type: Term.Assign #@
        - name: return
          type: Term.Return #@
        - name: throw
          type: Term.Throw #@
        - name: ascribe
          type: Term.Ascribe #@
        - name: annotate
          type: Term.Annotate #@
        - name: tuple
          type: Term.Tuple #@
        - name: block
          type: Term.Block #@
        - name: endMarker
          type: Term.EndMarker #@
        - name: if
          type: Term.If #@
        - name: quotedMacroExpr
          type: Term.QuotedMacroExpr #@
        - name: quotedMacroType
          type: Term.QuotedMacroType #@
        - name: splicedMacroExpr
          type: Term.SplicedMacroExpr #@
        - name: match
          type: Term.Match #@
        - name: try
          type: Term.Try #@
        - name: tryWithHandler
          type: Term.TryWithHandler #@
        - name: functionTerm
          type: Term.FunctionTerm #@
        - name: polyFunction
          type: Term.PolyFunction #@
        - name: partialFunction
          type: Term.PartialFunction #@
        - name: while
          type: Term.While #@
        - name: do
          type: Term.Do #@
        - name: for
          type: Term.For #@
        - name: forYield
          type: Term.ForYield #@
        - name: new
          type: Term.New #@
        - name: newAnonymous
          type: Term.NewAnonymous #@
        - name: placeholder
          type: Term.Placeholder #@
        - name: eta
          type: Term.Eta #@
        - name: repeated
          type: Term.Repeated #@
        - name: param
          type: Term.Param
#object Term {
    innerTypes:
#  @branch trait Ref extends Term with scala.meta.Ref #@
      - name: Ref
        type:
          union:
          - name: this
            type: Term.This #@
          - name: super
            type: Term.Super #@
          - name: name
            type: Term.Name #@
          - name: anonymous
            type: Term.Anonymous #@
          - name: select
            type: Term.Select #@
          - name: applyUnary
            type: Term.ApplyUnary #@
#  @ast class This(qual: scala.meta.Name) extends Term.Ref #@
      - name: This
#  @ast class Super(thisp: scala.meta.Name, superp: scala.meta.Name) extends Term.Ref #@
      - name: Super
        type:
          record:
            - name: thisp
              type: Name
            - name: superp
              type: Name
#  @ast class Name(value: Predef.String @nonEmpty) extends scala.meta.Name with Term.Ref with Pat #@
      - name: Name
        type:
          record:
            - name: value
              type: PredefString
#  @ast class Anonymous() extends scala.meta.Name with Term.Ref { #@
      - name: Anonymous
#    def value = ""
#    checkParent(ParentChecks.AnonymousImport)
#  }
#  @ast class Select(qual: Term, name: Term.Name) extends Term.Ref with Pat #@
      - name: Select
        type:
          record:
            - name: qual
              type: Term
            - name: name
              type: Term.Name
#  @ast class Interpolate(prefix: Name, parts: List[Lit] @nonEmpty, args: List[Term]) extends Term { #@
      - name: Interpolate
        type:
          record:
            - name: prefix
              type: Term.Name
            - name: parts
              type:
                list: Lit
            - name: args
              type:
                list: Term
#    checkFields(parts.length == args.length + 1)
#  }
#  @ast class Xml(parts: List[Lit] @nonEmpty, args: List[Term]) extends Term { #@
      - name: Xml
        type:
          record:
            - name: parts
              type:
                list: Lit
            - name: args
              type:
                list: Term
#    checkFields(parts.length == args.length + 1)
#  }
#  @ast class Apply(fun: Term, args: List[Term]) extends Term #@
      - name: Apply
        type:
          record:
            - name: fun
              type: Term
            - name: args
              type:
                list: Term
#  @ast class ApplyUsing(fun: Term, args: List[Term]) extends Term #@
      - name: ApplyUsing
        type:
          record:
            - name: fun
              type: Term
            - name: targs
              type:
                list: Type
#  @ast class ApplyType(fun: Term, targs: List[Type] @nonEmpty) extends Term #@
      - name: ApplyType
        type:
          record:
            - name: lhs
              type: Term
            - name: op
              type: Term.Name
            - name: targs
              type:
                list: Type
            - name: args
              type:
                list: Term
#  @ast class ApplyInfix(lhs: Term, op: Name, targs: List[Type], args: List[Term]) extends Term #@
      - name: ApplyInfix
        type:
          record:
            - name: lhs
              type: Term
            - name: op
              type: Term.Name
            - name: targs
              type:
                list: Type
            - name: args
              type:
                list: Term
#  @ast class ApplyUnary(op: Name, arg: Term) extends Term.Ref { #@
      - name: ApplyUnary
        type:
          record:
            - name: op
              type: Term.Name
            - name: arg
              type: Term
#    checkFields(op.isUnaryOp)
#  }
#  @ast class Assign(lhs: Term, rhs: Term) extends Term { #@
      - name: Assign
        type:
          record:
            - name: lhs
              type: Term
            - name: rhs
              type: Term
#    checkFields(lhs.is[Term.Quasi] || lhs.is[Term.Ref] || lhs.is[Term.Apply])
#    checkParent(ParentChecks.TermAssign)
#  }
#  @ast class Return(expr: Term) extends Term #@
      - name: Return
        type:
          record:
            - name: expr
              type: Term
#  @ast class Throw(expr: Term) extends Term #@
      - name: Throw
        type:
          record:
            - name: expr
              type: Term
#  @ast class Ascribe(expr: Term, tpe: Type) extends Term #@
      - name: Ascribe
        type:
          record:
            - name: expr
              type: Term
            - name: tpe
              type: Type
#  @ast class Annotate(expr: Term, annots: List[Mod.Annot] @nonEmpty) extends Term #@
      - name: Annotate
        type:
          record:
            - name: expr
              type: Term
            - name: annots
              type:
                list: Mod.Annot
#  @ast class Tuple(args: List[Term] @nonEmpty) extends Term { #@
      - name: Tuple
        type:
          record:
            - name: args
              type:
                list: Term
#    // tuple must have more than one element
#    // however, this element may be Quasi with "hidden" list of elements inside
#    checkFields(args.length > 1 || (args.length == 1 && args.head.is[Term.Quasi]))
#  }
#  @ast class Block(stats: List[Stat]) extends Term { #@
      - name: Block
        type:
          record:
            - name: stats
              type:
                list: Stat
#    // extension group block can have declarations without body too
#    checkFields(stats.forall(st => st.isBlockStat || st.is[Decl]))
#  }
#  @ast class EndMarker(name: Term.Name) extends Term #@
      - name: EndMarker
        type:
          record:
            - name: name
              type: Term.Name
#  @ast class If(cond: Term, thenp: Term, elsep: Term) extends Term { #@
      - name: If
        type:
          record:
            - name: cond
              type: Term
            - name: thenp
              type: Term
            - name: elsep
              type: Term
#    @binaryCompatField(since = "4.4.0")
#    private var _mods: List[Mod] = Nil
#  }
#  @ast class QuotedMacroExpr(body: Term) extends Term #@
      - name: QuotedMacroExpr
        type:
          record:
            - name: body
              type: Term
#  @ast class QuotedMacroType(tpe: Type) extends Term #@
      - name: QuotedMacroType
        type:
          record:
            - name: tpe
              type: Type
#  @ast class SplicedMacroExpr(body: Term) extends Term #@
      - name: SplicedMacroExpr
        type:
          record:
            - name: body
              type: Term
#  @ast class Match(expr: Term, cases: List[Case] @nonEmpty) extends Term { #@
      - name: Match
        type:
          record:
            - name: expr
              type: Term
            - name: cases
              type:
                list: Case
#    @binaryCompatField(since = "4.4.5")
#    private var _mods: List[Mod] = Nil
#  }
#  @ast class Try(expr: Term, catchp: List[Case], finallyp: Option[Term]) extends Term #@
      - name: Try
        type:
          record:
            - name: expr
              type: Term
            - name: catchp
              type:
                list: Case
            - name: finallyp
              type:
                optional: Term
#  @ast class TryWithHandler(expr: Term, catchp: Term, finallyp: Option[Term]) extends Term #@
      - name: TryWithHandler
        type:
          record:
            - name: expr
              type: Term
            - name: catchp
              type: Term
            - name: finallyp
              type:
                optional: Term
#
#  @branch trait FunctionTerm extends Term { #@
      - name: FunctionTerm
        type:
          union:
            - name: contextFunction
              type: Term.ContextFunction #@
            - name: Function
              type: Term.Function #@
#    def params: List[Term.Param]
#    def body: Term
#  }
#  @ast class ContextFunction(params: List[Term.Param], body: Term) extends FunctionTerm { #@
      - name: ContextFunction
        type:
          record:
            - name: params
              type:
                list: Term.Param
            - name: body
              type: Term
#    checkFields(
#      params.forall(param =>
#        param.is[Term.Param.Quasi] ||
#          (param.name.is[scala.meta.Name.Anonymous] ==> param.default.isEmpty)
#      )
#    )
#  }
#  @ast class Function(params: List[Term.Param], body: Term) extends FunctionTerm { #@
      - name: Function
        type:
          record:
            - name: params
              type:
                list: Term.Param
            - name: body
              type: Term
#    checkFields(
#      params.forall(param =>
#        param.is[Term.Param.Quasi] ||
#          (param.name.is[scala.meta.Name.Anonymous] ==> param.default.isEmpty)
#      )
#    )
#    checkFields(
#      params.exists(_.is[Term.Param.Quasi]) ||
#        params.exists(_.mods.exists(_.is[Mod.Implicit])) ==> (params.length == 1)
#    )
#  }
#  @ast class PolyFunction(tparams: List[Type.Param], body: Term) extends Term #@
      - name: PolyFunction
        type:
          record:
            - name: tparams
              type:
                list: Type.Param
            - name: body
              type: Term
#  @ast class PartialFunction(cases: List[Case] @nonEmpty) extends Term #@
      - name: PartialFunction
        type:
          record:
            - name: cases
              type:
                list: Case
#  @ast class While(expr: Term, body: Term) extends Term #@
      - name: While
        type:
          record:
            - name: expr
              type: Term
            - name: body
              type: Term
#  @ast class Do(body: Term, expr: Term) extends Term #@
      - name: Do
        type:
          record:
            - name: body
              type: Term
            - name: expr
              type: Term
#  @ast class For(enums: List[Enumerator] @nonEmpty, body: Term) extends Term { #@
      - name: For
        type:
          record:
            - name: enums
              type:
                list: Enumerator
#    checkFields(
#      enums.head.is[Enumerator.Generator] || enums.head.is[Enumerator.CaseGenerator] || enums.head
#        .is[Enumerator.Quasi]
#    )
#  }
#  @ast class ForYield(enums: List[Enumerator] @nonEmpty, body: Term) extends Term #@
      - name: ForYield
        type:
          record:
            - name: enums
              type:
                list: Enumerator
#  @ast class New(init: Init) extends Term #@
      - name: New
        type:
          record:
            - name: init
              type: Init
#  @ast class NewAnonymous(templ: Template) extends Term #@
      - name: NewAnonymous
        type:
          record:
            - name: templ
              type: Template
#  @ast class Placeholder() extends Term #@
      - name: Placeholder
#  @ast class Eta(expr: Term) extends Term #@
      - name: Eta
        type:
          record:
            - name: expr
              type: Term
#  @ast class Repeated(expr: Term) extends Term { #@
      - name: Repeated
        type:
          record:
            - name: expr
              type: Term
#    checkParent(ParentChecks.TermRepeated)
#  }
#  @ast class Param(mods: List[Mod], name: meta.Name, decltpe: Option[Type], default: Option[Term])
#      extends Member #@
      - name: Param
        type:
          record:
            - name: mods
              type:
                list: Mod
            - name: name
              type: Name
            - name: decltpe
              type:
                optional: Type
            - name: default
              type:
                optional: Term
#  def fresh(): Term.Name = fresh("fresh")
#  def fresh(prefix: String): Term.Name = Term.Name(prefix + Fresh.nextId())
#}
#
#@branch trait Type extends Tree #@
  - name: Type
    type:
      union:
        - name: ref
          type: Type.Ref #@
        - name: anonymousName
          type: Type.AnonymousName #@
        - name: apply
          type: Type.Apply #@
        - name: applyInfix
          type: Type.ApplyInfix #@
        - name: functionType
          type: Type.FunctionType #@
        - name: polyFunction
          type: Type.PolyFunction #@
        - name: implicitFunction
          type: Type.ImplicitFunction #@
        - name: tuple
          type: Type.Tuple #@
        - name: with
          type: Type.With #@
        - name: and
          type: Type.And #@
        - name: or
          type: Type.Or #@
        - name: refine
          type: Type.Refine #@
        - name: existential
          type: Type.Existential #@
        - name: annotate
          type: Type.Annotate #@
        - name: lambda
          type: Type.Lambda #@
        - name: macro
          type: Type.Macro #@
        - name: method
          type: Type.Method #@
        - name: placeholder
          type: Type.Placeholder #@
        - name: byName
          type: Type.ByName #@
        - name: repeated
          type: Type.Repeated #@
        - name: var
          type: Type.Var #@
        - name: typedParam
          type: Type.TypedParam #@
        - name: match
          type: Type.Match #@
#object Type {
    innerTypes:
#  @branch trait Ref extends Type with scala.meta.Ref #@
      - name: Ref
        type:
          union:
          - name: name
            type: Type.Name #@
          - name: select
            type: Type.Select #@
          - name: project
            type: Type.Project #@
          - name: singleton
            type: Type.Singleton #@
#  @ast class Name(value: String @nonEmpty) extends scala.meta.Name with Type.Ref #@
      - name: Name
        type:
          record:
            - name: value
              type: string
#  @ast class AnonymousName() extends Type #@
      - name: AnonymousName
#  @ast class Select(qual: Term.Ref, name: Type.Name) extends Type.Ref { #@
      - name: Select
        type:
          record:
            - name: qual
              type: Term.Ref
            - name: name
              type: Type.Name
#    checkFields(qual.isPath || qual.is[Term.Super] || qual.is[Term.Ref.Quasi])
#  }
#  @ast class Project(qual: Type, name: Type.Name) extends Type.Ref #@
      - name: Project
        type:
          record:
            - name: qual
              type: Type
            - name: name
              type: Type.Name
#  @ast class Singleton(ref: Term.Ref) extends Type.Ref { #@
      - name: Singleton
        type:
          record:
            - name: ref
              type: Term.Ref
#    checkFields(ref.isPath || ref.is[Term.Super])
#  }
#  @ast class Apply(tpe: Type, args: List[Type] @nonEmpty) extends Type #@
      - name: Apply
        type:
          record:
            - name: tpe
              type: Type
            - name: args
              type:
                list: Type
#  @ast class ApplyInfix(lhs: Type, op: Name, rhs: Type) extends Type #@
      - name: ApplyInfix
        type:
          record:
            - name: lhs
              type: Type
            - name: op
              type: Type.Name
            - name: rhs
              type: Type
#  @branch trait FunctionType extends Type { #@
      - name: FunctionType
        type:
          union:
          - name: function
            type: Type.Function #@
          - name: contextFunction
            type: Type.ContextFunction #@
#    def params: List[Type]
#    def res: Type
#  }
#  @ast class Function(params: List[Type], res: Type) extends FunctionType #@
      - name: Function
        type:
          record:
            - name: params
              type:
                list: Type
            - name: res
              type: Type
#  @ast class PolyFunction(tparams: List[Type.Param], tpe: Type) extends Type #@
      - name: PolyFunction
        type:
          record:
            - name: tparams
              type:
                list: Type.Param
            - name: tpe
              type: Type
#  @ast class ContextFunction(params: List[Type], res: Type) extends FunctionType #@
      - name: ContextFunction
        type:
          record:
            - name: params
              type:
                list: Type
            - name: res
              type: Type
#  @ast @deprecated("Implicit functions are not supported in any dialect")
#  class ImplicitFunction(
      - name: ImplicitFunction
        type:
          record:
#      params: List[Type],
            - name: params
              type:
                list: Type
#      res: Type
            - name: res
              type: Type
#  ) extends Type #@
#  @ast class Tuple(args: List[Type] @nonEmpty) extends Type { #@
      - name: Tuple
        type:
          record:
            - name: args
              type:
                list: Type
#    checkFields(args.length > 1 || (args.length == 1 && args.head.is[Type.Quasi]))
#  }
#  @ast class With(lhs: Type, rhs: Type) extends Type #@
      - name: With
        type:
          record:
            - name: lhs
              type: Type
            - name: rhs
              type: Type
#  @ast class And(lhs: Type, rhs: Type) extends Type #@
      - name: And
        type:
          record:
            - name: lhs
              type: Type
            - name: rhs
              type: Type
#  @ast class Or(lhs: Type, rhs: Type) extends Type #@
      - name: Or
        type:
          record:
            - name: lhs
              type: Type
            - name: rhs
              type: Type
#  @ast class Refine(tpe: Option[Type], stats: List[Stat]) extends Type { #@
      - name: Refine
        type:
          record:
            - name: tpe
              type:
                optional: Type
            - name: stats
              type:
                list: Stat
#    checkFields(stats.forall(_.isRefineStat))
#  }
#  @ast class Existential(tpe: Type, stats: List[Stat] @nonEmpty) extends Type { #@
      - name: Existential
        type:
          record:
            - name: tpe
              type: Type
            - name: stats
              type:
                list: Stat
#    checkFields(stats.forall(_.isExistentialStat))
#  }
#  @ast class Annotate(tpe: Type, annots: List[Mod.Annot] @nonEmpty) extends Type #@
      - name: Annotate
        type:
          record:
            - name: tpe
              type: Type
            - name: annots
              type:
                list: Mod.Annot
#  @ast class Lambda(tparams: List[Type.Param], tpe: Type) extends Type { #@
      - name: Lambda
        type:
          record:
            - name: tparams
              type:
                list: Type.Param
            - name: tpe
              type: Type
#    checkParent(ParentChecks.TypeLambda)
#  }
#  @ast class Macro(body: Term) extends Type #@
      - name: Macro
        type:
          record:
            - name: body
              type: Term
#  @deprecated("Method type syntax is no longer supported in any dialect", "4.4.3")
#  @ast class Method(paramss: List[List[Term.Param]], tpe: Type) extends Type { #@
      - name: Method
        type:
          record:
            - name: paramss
              type:
                list:
                  list: Term.Param
            - name: tpe
              type: Type
#    checkParent(ParentChecks.TypeMethod)
#  }
#  @ast class Placeholder(bounds: Bounds) extends Type #@
      - name: Placeholder
        type:
          record:
            - name: bounds
              type: Type.Bounds
#  @ast class Bounds(lo: Option[Type], hi: Option[Type]) extends Tree #@
      - name: Bounds
        type:
          record:
            - name: lo
              type:
                optional: Type
            - name: hi
              type:
                optional: Type
#  @ast class ByName(tpe: Type) extends Type { #@
      - name: ByName
        type:
          - name: tpe
            type: Type
#    checkParent(ParentChecks.TypeByName)
#  }
#  @ast class Repeated(tpe: Type) extends Type { #@
      - name: Repeated
        type:
          record:
            - name: tpe
              type: Type
#    checkParent(ParentChecks.TypeRepeated)
#  }
#  @ast class Var(name: Name) extends Type with Member.Type { #@
      - name: Var
        type:
          record:
            - name: name
              type: Type.Name
#    checkFields(name.value(0).isLower)
#    checkParent(ParentChecks.TypeVar)
#  }
#
#  @ast class TypedParam(name: Name, typ: Type) extends Type with Member.Type #@
      - name: TypedParam
        type:
          record:
            - name: name
              type: Name
            - name: typ
              type: Type
#  @ast class Param(
      - name: Param
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: meta.Name,
            - name: name
              type: Name
#      tparams: List[Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      tbounds: Type.Bounds,
            - name: tbounds
              type:
                list: Type.Bounds
#      vbounds: List[Type],
            - name: vbounds
              type:
                list: Type
#      cbounds: List[Type]
            - name: cbounds
              type:
                list: Type
#  ) extends Member #@
#
#  @ast class Match(tpe: Type, cases: List[TypeCase] @nonEmpty) extends Type #@
      - name: Match
        type:
          record:
            - name: tpe
              type: Type
            - name: cases
              type:
                list: TypeCase
#  def fresh(): Type.Name = fresh("fresh")
#  def fresh(prefix: String): Type.Name = Type.Name(prefix + Fresh.nextId())
#}
#
#@branch trait Pat extends Tree #@
  - name: Pat
    type:
      union:
        - name: var
          type: Pat.Var #@
        - name: wildcard
        - name: seqWildcard
        - name: bind
          type: Pat.Bind #@
        - name: alternative
          type: Pat.Alternative #@
        - name: tuple
          type: Pat.Tuple #@
        - name: repeated
          type: Pat.Repeated #@
        - name: extract
          type: Pat.Extract #@
        - name: extractInfix
          type: Pat.ExtractInfix #@
        - name: interpolate
          type: Pat.Interpolate #@
        - name: xml
          type: Pat.Xml #@
        - name: typed
          type: Pat.Typed #@
        - name: macro
          type: Pat.Macro #@
        - name: given
          type: Pat.Given #@
#object Pat {
    innerTypes:
#  @ast class Var(name: scala.meta.Term.Name) extends Pat with Member.Term { #@@
      - name: Var
        type:
          record:
            - name: name
              type: Term.Name
#    // NOTE: can't do this check here because of things like `val X = 2`
#    // checkFields(name.value(0).isLower)
#    checkParent(ParentChecks.PatVar)
#  }
#  @ast class Wildcard() extends Pat #@
#  @ast class SeqWildcard() extends Pat { #@
#    checkParent(ParentChecks.PatSeqWildcard)
#  }
#  @ast class Bind(lhs: Pat, rhs: Pat) extends Pat { #@
      - name: Bind
        type:
          record:
            - name: lhs
              type: Pat
            - name: rhs
              type: Pat
#    checkFields(lhs.is[Pat.Var] || lhs.is[Pat.Quasi])
#  }
#  @ast class Alternative(lhs: Pat, rhs: Pat) extends Pat #@
      - name: Alternative
        type:
          record:
            - name: lhs
              type: Pat
            - name: rhs
              type: Pat
#  @ast class Tuple(args: List[Pat] @nonEmpty) extends Pat { #@
      - name: Tuple
        type:
          record:
            - name: args
              type:
                list: Pat
#    checkFields(args.length > 1 || (args.length == 1 && args.head.is[Pat.Quasi]))
#  }
#  @ast class Repeated(name: scala.meta.Term.Name) extends Pat #@
      - name: Repeated
        type:
          record:
            - name: name
              type: Term.Name
#  @ast class Extract(fun: Term, args: List[Pat]) extends Pat { #@
      - name: Extract
        type:
          record:
            - name: fun
              type: Term
            - name: args
              type:
                list: Pat
#    checkFields(fun.isExtractor)
#  }
#  @ast class ExtractInfix(lhs: Pat, op: Term.Name, rhs: List[Pat]) extends Pat #@
      - name: ExtractInfix
        type:
          record:
            - name: lhs
              type: Pat
            - name: op
              type: Term.Name
            - name: rhs
              type:
                list: Pat
#  @ast class Interpolate(prefix: Term.Name, parts: List[Lit] @nonEmpty, args: List[Pat])
      - name: Interpolate
        type:
          record:
            - name: prefix
              type: Term.Name
            - name: parts
              type:
                list: Lit
#      extends Pat { #@
#    checkFields(parts.length == args.length + 1)
#  }
#  @ast class Xml(parts: List[Lit] @nonEmpty, args: List[Pat]) extends Pat { #@
      - name: Xml
        type:
          record:
            - name: parts
              type:
                list: Lit
            - name: args
              type:
                list: Pat
#    checkFields(parts.length == args.length + 1)
#  }
#  @ast class Typed(lhs: Pat, rhs: Type) extends Pat { #@
      - name: Typed
        type:
          record:
            - name: lhs
              type: Pat
            - name: rhs
              type: Type
#    checkFields(!rhs.is[Type.Var] && !rhs.is[Type.Placeholder])
#  }
#  @ast class Macro(body: Term) extends Pat { #@
      - name: Macro
        type:
          record:
            - name: body
              type: Term
#    checkFields(body.is[Term.QuotedMacroExpr] || body.is[Term.QuotedMacroType])
#  }
#  @ast class Given(tpe: Type) extends Pat #@
      - name: Given
        type:
          record:
            - name: tpe
              type: Type
#  def fresh(): Pat.Var = Pat.Var(Term.fresh())
#  def fresh(prefix: String): Pat.Var = Pat.Var(Term.fresh(prefix))
#}
#
#@branch trait Member extends Tree { #@
  - name: Member
    type:
      union:
        - name: term
          type: Member.Term #@
        - name: type
          type: Member.Type #@
        - name: termParam
          type: Term.Param #@
        - name: typeParam
          type: Type.Param #@
        - name: self
          type: Self #@
#  def name: Name
#}
#object Member {
    innerTypes:
#  @branch trait Term extends Member { #@
      - name: Term
        type:
          union:
            - name: pkg
              type: Pkg #@@
            - name: object
              type: Pkg.Object #@@
#    def name: scala.meta.Term.Name
#  }
#  @branch trait Type extends Member { #@
      - name: Type
        type:
          record:
#    def name: scala.meta.Type.Name
            - name: name
              type: Type.Name
#  }
#}
#
#@branch trait Decl extends Stat #@
  - name: Decl
    type:
      union:
        - name: val
          type: Decl.Val #@
        - name: var
          type: Decl.Var #@
        - name: def
          type: Decl.Def #@
        - name: type
          type: Decl.Type #@
        - name: given
          type: Decl.Given #@
#object Decl {
    innerTypes:
#  @ast class Val(mods: List[Mod], pats: List[Pat] @nonEmpty, decltpe: scala.meta.Type) extends Decl #@
      - name: Val
        type:
          record:
            - name: mods
              type:
                list: Mod
            - name: pats
              type:
                list: Pat
            - name: decltpe
              type: Type
#  @ast class Var(mods: List[Mod], pats: List[Pat] @nonEmpty, decltpe: scala.meta.Type) extends Decl #@
      - name: Var
        type:
          record:
            - name: mods
              type:
                list: Mod
            - name: pats
              type:
                list: Pat
            - name: decltpe
              type: Type
#  @ast class Def(
      - name: Def
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: Term.Name,
            - name: name
              type: Term.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      paramss: List[List[Term.Param]],
            - name: paramss
              type:
                list:
                  list: Term.Param
#      decltpe: scala.meta.Type
            - name: decltpe
              type: Type
#  ) extends Decl with Member.Term #@@
      #  @ast class Type(
      - name: Type
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Type.Name,
            - name: name
              type: Type.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      bounds: scala.meta.Type.Bounds
            - name: bounds
              type: Type.Bounds
#  ) extends Decl with Member.Type #@
#  @ast class Given(
      - name: Given
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: Term.Name,
            - name: name
              type: Term.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      sparams: List[List[Term.Param]],
            - name: sparams
              type:
                list:
                  list: Term.Param
#      decltpe: scala.meta.Type
            - name: decltpe
              type: Type
#  ) extends Decl with Member.Term #@@
#}
#
#@branch trait Defn extends Stat #@
  - name: Defn
    type:
      union:
        - name: val
          type: Defn.Val #@
        - name: var
          type: Defn.Var #@
        - name: given
          type: Defn.Given #@
        - name: enum
          type: Defn.Enum #@
        - name: enumCase
          type: Defn.EnumCase #@
        - name: repeatedEnumCase
          type: Defn.RepeatedEnumCase #@
        - name: givenAlias
          type: Defn.GivenAlias #@
        - name: extensionGroup
          type: Defn.ExtensionGroup #@
        - name: def
          type: Defn.Def #@
        - name: macro
          type: Defn.Macro #@
        - name: type
          type: Defn.Type #@
        - name: class
          type: Defn.Class #@
        - name: trait
          type: Defn.Trait #@
        - name: object
          type: Defn.Object #@
#object Defn {
    innerTypes:
#  @ast class Val(
      - name: Val
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      pats: List[Pat] @nonEmpty,
            - name: pats
              type:
                list: Pat
#      decltpe: Option[scala.meta.Type],
            - name: decltpe
              type:
                optional: Type
#      rhs: Term
            - name: rhs
              type: Term
#  ) extends Defn { #@
#    checkFields(pats.forall(!_.is[Term.Name]))
#  }
#  @ast class Var(
      - name: Var
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      pats: List[Pat] @nonEmpty,
            - name: pats
              type:
                list: Pat
#      decltpe: Option[scala.meta.Type],
            - name: decltpe
              type: Type
#      rhs: Option[Term]
            - name: rhs
              type:
                optional: Term
#  ) extends Defn { #@
#    checkFields(pats.forall(!_.is[Term.Name]))
#    checkFields(decltpe.nonEmpty || rhs.nonEmpty)
#    checkFields(rhs.isEmpty ==> pats.forall(_.is[Pat.Var]))
#  }
#  @ast class Given(
      - name: Given
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Name,
            - name: name
              type: Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list:
                  list: Type.Param
#      sparams: List[List[Term.Param]],
            - name: sparams
              type:
                list:
                  list: Term.Param
#      templ: Template
            - name: templ
              type: Template
#  ) extends Defn #@
#  @ast class Enum(
      - name: Enum
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Type.Name,
            - name: name
              type: Type.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      ctor: Ctor.Primary,
            - name: ctor
              type: Ctor.Primary
#      templ: Template
            - name: template
              type: Template
#  ) extends Defn with Member.Type #@
#  @ast class EnumCase(
      - name: EnumCase
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: Term.Name,
            - name: name
              type: Term.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      ctor: Ctor.Primary,
            - name: ctor
              type: Ctor.Primary
#      inits: List[Init]
            - name: inits
              type:
                list: Init
#  ) extends Defn with Member.Term { #@@
#    checkParent(ParentChecks.EnumCase)
#  }
#  @ast class RepeatedEnumCase(
      - name: RepeatedEnumCase
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      cases: List[Term.Name]
            - name: cases
              type:
                list: Term.Name
#  ) extends Defn { #@
#    checkParent(ParentChecks.EnumCase)
#  }
#  @ast class GivenAlias(
      - name: GivenAlias
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Name,
            - name: name
              type: Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list:
                  list: Type.Param
#      sparams: List[List[Term.Param]],
            - name: sparams
              type:
                list:
                  list: Term.Param
#      decltpe: scala.meta.Type,
            - name: decltpe
              type: Type
#      body: Term
            - name: body
              type: Term
#  ) extends Defn #@
#  @ast class ExtensionGroup(
      - name: ExtensionGroup
        type:
          record:
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      paramss: List[List[Term.Param]],
            - name: paramss
              type:
                list:
                  list: Term.Param
#      body: Stat
            - name: body
              type: Stat
#  ) extends Defn #@
#  @ast class Def(
      - name: Def
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: Term.Name,
            - name: name
              type: Term.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      paramss: List[List[Term.Param]],
            - name: paramss
              type:
                list:
                  list: Term.Param
#      decltpe: Option[scala.meta.Type],
            - name: decltpe
              type:
                optional: Type
#      body: Term
            - name: body
              type: Term
#  ) extends Defn with Member.Term { #@@
#    checkFields(paramss.forall(onlyLastParamCanBeRepeated))
#  }
#  @ast class Macro(
      - name: Macro
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: Term.Name,
            - name: name
              type: Term.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      paramss: List[List[Term.Param]],
            - name: paramss
              type:
                list:
                  list: Term.Param
#      decltpe: Option[scala.meta.Type],
            - name: decltpe
              type:
                optional: Type
#      body: Term
            - name: body
              type: Term
#  ) extends Defn with Member.Term #@@
#  @ast class Type(
      - name: Type
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Type.Name,
            - name: name
              type: Type.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      body: scala.meta.Type
            - name: body
              type: Type
#  ) extends Defn with Member.Type { #@
#    @binaryCompatField("4.4.0")
#    private var _bounds: scala.meta.Type.Bounds = scala.meta.Type.Bounds(None, None)
#  }
#  @ast class Class(
      - name: Class
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Type.Name,
            - name: name
              type: Type.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      ctor: Ctor.Primary,
            - name: ctor
              type: Ctor.Primary
#      templ: Template
            - name: template
              type: Template
#  ) extends Defn with Member.Type #@
#  @ast class Trait(
      - name: Trait
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: scala.meta.Type.Name,
            - name: name
              type: Type.Name
#      tparams: List[scala.meta.Type.Param],
            - name: tparams
              type:
                list: Type.Param
#      ctor: Ctor.Primary,
            - name: ctor
              type: Ctor.Primary
#      templ: Template
            - name: template
              type: Template
#  ) extends Defn with Member.Type { #@
#    checkFields(templ.is[Template.Quasi] || templ.stats.forall(!_.is[Ctor]))
#  }
#  @ast class Object(mods: List[Mod], name: Term.Name, templ: Template)
      - name: Object
        type:
          record:
            - name: name # from Member.Term
              type: Term.Name
#      extends Defn with Member.Term { #@@
#    checkFields(templ.is[Template.Quasi] || templ.stats.forall(!_.is[Ctor]))
#  }
#}
#
#@ast class Pkg(ref: Term.Ref, stats: List[Stat]) extends Member.Term with Stat { #@@
  - name: Pkg
    type:
      record:
        - name: name # from Member.Term
          type: Term.Name
        - name: ref
          type: Term.Ref
        - name: stats
          type:
            list: Stat
#  checkFields(ref.isQualId)
#  def name: Term.Name = ref match {
#    case name: Term.Name => name
#    case Term.Select(_, name: Term.Name) => name
#  }
#}
#object Pkg {
    innerTypes:
#  @ast class Object(mods: List[Mod], name: Term.Name, templ: Template)
#      extends Member.Term with Stat { #@@
      - name: Object
        type:
          record:
            - name: mods
              type:
                list: Mod
            - name: name
              type: Term.Name
            - name: template
              type: Template
#    checkFields(templ.is[Template.Quasi] || templ.stats.forall(!_.is[Ctor]))
#  }
#}
#
#// NOTE: The names of Ctor.Primary and Ctor.Secondary here is always Name.Anonymous.
#// While seemingly useless, this name is crucial to one of the key principles behind the semantic API:
#// "every definition and every reference should carry a name".
#@branch trait Ctor extends Tree with Member #@
  - name: Ctor
    type:
      union:
        - name: primary
          type: Ctor.Primary #@
        - name: secondary
          type: Ctor.Secondary #@
#object Ctor {
    innerTypes:
#  @ast class Primary(mods: List[Mod], name: Name, paramss: List[List[Term.Param]]) extends Ctor #@
      - name: Primary
        type:
          record:
            - name: mods
              type:
                list: Mod
            - name: name
              type: Name
            - name: paramss
              type:
                list:
                  list: Term.Param
#  @ast class Secondary(
      - name: Secondary
        type:
          record:
#      mods: List[Mod],
            - name: mods
              type:
                list: Mod
#      name: Name,
            - name: name
              type: Name
#      paramss: List[List[Term.Param]] @nonEmpty,
            - name: paramss
              type:
                list:
                  list: Term.Param
#      init: Init,
            - name: init
              type: Init
#      stats: List[Stat]
            - name: stats
              type:
                list: Stat
#  ) extends Ctor with Stat { #@
#    checkFields(stats.forall(_.isBlockStat))
#  }
#}
#
#// NOTE: The name here is always Name.Anonymous.
#// See comments to Ctor.Primary and Ctor.Secondary for justification.
#@ast class Init(tpe: Type, name: Name, argss: List[List[Term]]) extends Ref { #@
  - name: Init
    type:
      record:
        - name: tpe
          type: Type
        - name: name
          type: Name
        - name: argss
          type:
            list:
              list: Term
#  checkFields(tpe.isConstructable)
#  checkParent(ParentChecks.Init)
#}
#
#@ast class Self(name: Name, decltpe: Option[Type]) extends Member #@
  - name: Self
#
#@ast class Template(
  - name: Template
    type:
      record:
#    early: List[Stat],
        - name: early
          type:
            list: Stat
#    inits: List[Init],
        - name: inits
          type:
            list: Init
#    self: Self,
        - name: self
          type: Self
#    stats: List[Stat]
        - name: stats
          type:
            list: Stat
#) extends Tree { #@
#  @binaryCompatField("4.4.0")
#  private var _derives: List[Type] = Nil
#  checkFields(early.forall(_.isEarlyStat && inits.nonEmpty))
#  checkFields(stats.forall(_.isTemplateStat))
#}
#
#@branch trait Mod extends Tree #@
  - name: Mod
    type:
      union:
        - name: annot
          type: Mod.Annot #@
        - name: private
          type: Mod.Private #@
        - name: protected
          type: Mod.Protected #@
        - name: implicit
        - name: final
        - name: sealed
        - name: open
        - name: super
        - name: override
        - name: case
        - name: abstract
        - name: covariant
        - name: contravariant
        - name: lazy
        - name: valParam
        - name: varParam
        - name: infix
        - name: inline
        - name: using
        - name: opaque
        - name: transparent
#object Mod {
    innerTypes:
#  @ast class Annot(init: Init) extends Mod { #@
      - name: Annot
        type:
          record:
            - name: init
              type: Init
#    @deprecated("Use init instead", "1.9.0")
#    def body = init
#  }
#  @ast class Private(within: Ref) extends Mod { #@
      - name: Private
        type:
          record:
            - name: within
              type: Ref
#    checkFields(within.isWithin)
#  }
#  @ast class Protected(within: Ref) extends Mod { #@
      - name: Protected
        type:
          record:
            - name: within
              type: Ref
#    checkFields(within.isWithin)
#  }
#  @ast class Implicit() extends Mod #@
#  @ast class Final() extends Mod #@
#  @ast class Sealed() extends Mod #@
#  @ast class Open() extends Mod #@
#  @deprecated("Super traits introduced in dotty, but later removed.")
#  @ast class Super() extends Mod #@
#  @ast class Override() extends Mod #@
#  @ast class Case() extends Mod #@
#  @ast class Abstract() extends Mod #@
#  @ast class Covariant() extends Mod #@
#  @ast class Contravariant() extends Mod #@
#  @ast class Lazy() extends Mod #@
#  @ast class ValParam() extends Mod #@
#  @ast class VarParam() extends Mod #@
#  @ast class Infix() extends Mod #@
#  @ast class Inline() extends Mod #@
#  @ast class Using() extends Mod #@
#  @ast class Opaque() extends Mod #@
#  @ast class Transparent() extends Mod #@
#}
#
#@branch trait Enumerator extends Tree #@
  - name: Enumerator
    type:
      union:
        - name: generator
          type: Enumerator.Generator #@
        - name: caseGenerator
          type: Enumerator.CaseGenerator #@
        - name: val
          type: Enumerator.Val #@
        - name: guard
          type: Enumerator.Guard #@
#object Enumerator {
    innerTypes:
#  @ast class Generator(pat: Pat, rhs: Term) extends Enumerator #@
      - name: Generator
        type:
          record:
            - name: pat
              type: Pat
            - name: rhs
              type: Term
#  @ast class CaseGenerator(pat: Pat, rhs: Term) extends Enumerator #@
      - name: CaseGenerator
        type:
          record:
            - name: pat
              type: Pat
            - name: rhs
              type: Term
#  @ast class Val(pat: Pat, rhs: Term) extends Enumerator #@
      - name: Val
        type:
          record:
            - name: pat
              type: Pat
            - name: rhs
              type: Term
#  @ast class Guard(cond: Term) extends Enumerator #@
      - name: Guard
        type:
          record:
            - name: cond
              type: Term
#}
#
#@branch trait ImportExportStat extends Stat { #@
  - name: ImportExportStat
    type:
      union:
        - name: import
          type: Import #@
        - name: export
          type: Export #@
#  def importers: List[Importer]
#}
#@ast class Import(importers: List[Importer] @nonEmpty) extends ImportExportStat #@
  - name: Import
    type:
      record:
        - name: importers
          type:
            list: Importer
#@ast class Export(importers: List[Importer] @nonEmpty) extends ImportExportStat #@
  - name: Export
    type:
      record:
        - name: importers
          type:
            list: Importer
#
#@ast class Importer(ref: Term.Ref, importees: List[Importee] @nonEmpty) extends Tree { #@
  - name: Importer
    type:
      record:
        - name: ref
          type: Term.Ref
        - name: importees
          type:
            list: Importee
#  checkFields(ref.isStableId)
#}
#
#@branch trait Importee extends Tree with Ref #@
  - name: Importee
    type:
      union:
        - name: wildcard
        - name: given
          type: Importee.Given #@
        - name: givenAll
        - name: name
          type: Importee.Name #@
        - name: rename
          type: Importee.Rename #@
        - name: unimport
          type: Importee.Unimport #@
#object Importee {
    innerTypes:
#  @ast class Wildcard() extends Importee #@
#  @ast class Given(tpe: Type) extends Importee #@
      - name: Given
        type:
          record:
            - name: tpe
              type: Type
#  @ast class GivenAll() extends Importee
#  @ast class Name(name: scala.meta.Name) extends Importee { #@
      - name: Name
        type:
          record:
            - name: name
              type: Name
#    checkFields(name.is[scala.meta.Name.Quasi] || name.is[scala.meta.Name.Indeterminate])
#  }
#  @ast class Rename(name: scala.meta.Name, rename: scala.meta.Name) extends Importee { #@
      - name: Rename
        type:
          record:
            - name: name
              type: Name
            - name: rename
              type: Name
#    checkFields(name.is[scala.meta.Name.Quasi] || name.is[scala.meta.Name.Indeterminate])
#    checkFields(rename.is[scala.meta.Name.Quasi] || rename.is[scala.meta.Name.Indeterminate])
#  }
#  @ast class Unimport(name: scala.meta.Name) extends Importee { #@
      - name: Unimport
        type:
          record:
            - name: name
              type: Name
#    checkFields(name.is[scala.meta.Name.Quasi] || name.is[scala.meta.Name.Indeterminate])
#  }
#}
#
#@branch trait CaseTree extends Tree { #@
  - name: CaseTree
    type:
      union:
        - name: case
          type: Case #@
        - name: typeCase
          type: TypeCase #@
#  def pat: Tree
#  def body: Tree
#}
#@ast class Case(pat: Pat, cond: Option[Term], body: Term) extends CaseTree #@
  - name: Case
    type:
      record:
        - name: pat
          type: Pat
        - name: cond
          type:
            optional: Term
        - name: body
          type: Term
#@ast class TypeCase(pat: Type, body: Type) extends CaseTree #@
  - name: TypeCase
    type:
      record:
        - name: pat
          type: Type
        - name: body
          type: Type
#
#@ast class Source(stats: List[Stat]) extends Tree { #@
  - name: Source
    type:
      record:
        - name: stats
          type:
            list: Stat
#  // NOTE: This validation has been removed to allow dialects with top-level terms.
#  // Ideally, we should push the validation into a dialect-specific prettyprinter when #220 is fixed.
#  // checkFields(stats.forall(_.isTopLevelStat))
#}
#
#package internal.trees {
#  // NOTE: Quasi is a base trait for a whole bunch of classes.
#  // Every root, branch and ast trait/class among scala.meta trees (except for quasis themselves)
#  // has a corresponding quasi, e.g. Term.Quasi or Type.Quasi.
#  //
#  // Here's how quasis represent unquotes
#  // (XXX below depends on the position where the unquote occurs, e.g. q"$x" will result in Term.Quasi):
#  //   * $x => XXX.Quasi(0, XXX.Name("x"))
#  //   * ..$xs => XXX.Quasi(1, XXX.Quasi(0, XXX.Name("xs"))
#  //   * ...$xss => XXX.Quasi(2, XXX.Quasi(0, XXX.Name("xss"))
#  //   * ..{$fs($args)} => Complex ellipses aren't supported yet
#  @branch trait Quasi extends Tree { #@
  - name: Quasi # TODO
#    def rank: Int
#    def tree: Tree
#    def pt: Class[_]
#    def become[T <: Quasi: AstInfo]: T
#  }
#
#  @registry object All
#}