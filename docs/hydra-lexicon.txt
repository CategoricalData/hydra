Elements:
  hydra.accessors.AccessorEdge = record{source = hydra.accessors.AccessorNode, path = hydra.accessors.AccessorPath, target = hydra.accessors.AccessorNode}
  hydra.accessors.AccessorGraph = record{nodes = list<hydra.accessors.AccessorNode>, edges = list<hydra.accessors.AccessorEdge>}
  hydra.accessors.AccessorNode = record{name = hydra.core.Name, label = string, id = string}
  hydra.accessors.AccessorPath = wrap[hydra.accessors.AccessorPath](list<hydra.accessors.TermAccessor>)
  hydra.accessors.TermAccessor = union{annotatedSubject = unit, applicationFunction = unit, applicationArgument = unit, lambdaBody = unit, unionCasesDefault = unit, unionCasesBranch = hydra.core.Name, letEnvironment = unit, letBinding = hydra.core.Name, listElement = int32, mapKey = int32, mapValue = int32, optionalTerm = unit, productTerm = int32, recordField = hydra.core.Name, setElement = int32, sumTerm = unit, typeAbstractionBody = unit, typeApplicationTerm = unit, injectionTerm = unit, wrappedTerm = unit}
  hydra.adapt.literals.comparePrecision : ((hydra.mantle.Precision → hydra.mantle.Precision → hydra.mantle.Comparison))
  hydra.adapt.literals.convertFloatValue : ((hydra.core.FloatType → hydra.core.FloatValue → hydra.core.FloatValue))
  hydra.adapt.literals.convertIntegerValue : ((hydra.core.IntegerType → hydra.core.IntegerValue → hydra.core.IntegerValue))
  hydra.adapt.literals.disclaimer : ((boolean → string → string → string))
  hydra.adapt.literals.floatAdapter : (∀[t0,t1].(hydra.core.FloatType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ t0 @ t1 @ hydra.core.FloatType @ hydra.core.FloatType @ hydra.core.FloatValue @ hydra.core.FloatValue))))
  hydra.adapt.literals.integerAdapter : (∀[t0,t1].(hydra.core.IntegerType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ t0 @ t1 @ hydra.core.IntegerType @ hydra.core.IntegerType @ hydra.core.IntegerValue @ hydra.core.IntegerValue))))
  hydra.adapt.literals.literalAdapter : (∀[t0].(hydra.core.LiteralType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ t0 @ t0 @ hydra.core.LiteralType @ hydra.core.LiteralType @ hydra.core.Literal @ hydra.core.Literal))))
  hydra.adapt.modules.adaptAndEncodeType : (∀[t0].(hydra.coders.Language → (hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.adapt.modules.adaptType : ((hydra.coders.Language → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.adapt.modules.adaptedModuleDefinitions : ((hydra.coders.Language → hydra.module.Module → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.module.Definition>)))
  hydra.adapt.modules.constructCoder : (∀[t0,t1,t2].(hydra.coders.Language → (hydra.core.Term → (hydra.compute.Flow @ t0 @ t1)) → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ (hydra.compute.Coder @ t0 @ t2 @ hydra.core.Term @ t1))))
  hydra.adapt.modules.languageAdapter : (∀[t0,t1].(hydra.coders.Language → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ (hydra.compute.Adapter @ t0 @ t1 @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.modules.transformModule : (∀[t0,t1,t2,t3].(hydra.coders.Language → (hydra.core.Term → (hydra.compute.Flow @ t0 @ t1)) → (hydra.module.Module → map<hydra.core.Type, (hydra.compute.Coder @ t0 @ t2 @ hydra.core.Term @ t1)> → list<hydra.graph.Element×hydra.core.TypedTerm> → (hydra.compute.Flow @ hydra.graph.Graph @ t3)) → hydra.module.Module → (hydra.compute.Flow @ hydra.graph.Graph @ t3)))
  hydra.adapt.terms.fieldAdapter : ((hydra.core.FieldType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.FieldType @ hydra.core.FieldType @ hydra.core.Field @ hydra.core.Field))))
  hydra.adapt.terms.forTypeReference : ((hydra.core.Name → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.functionProxyName : (hydra.core.Name)
  hydra.adapt.terms.functionProxyType : (∀[t0].(t0 → hydra.core.Type))
  hydra.adapt.terms.functionToUnion : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.lambdaToMonotype : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.listToSet : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.optionalToList : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passApplication : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passForall : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passFunction : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passList : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passLiteral : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passMap : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passOptional : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passProduct : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passRecord : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passSet : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passSum : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passUnion : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passUnit : (∀[t0,t1,t2,t3].(t0 → (hydra.compute.Flow @ t1 @ (hydra.compute.Adapter @ t2 @ t3 @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passWrapped : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.simplifyApplication : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.termAdapter : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.unionToRecord : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.unionTypeToRecordType : ((hydra.core.RowType → hydra.core.RowType))
  hydra.adapt.terms.unitToRecord : (∀[t0,t1,t2,t3].(t0 → (hydra.compute.Flow @ t1 @ (hydra.compute.Adapter @ t2 @ t3 @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.withGraphContext : (∀[t0].((hydra.compute.Flow @ hydra.graph.Graph @ t0) → (hydra.compute.Flow @ hydra.coders.AdapterContext @ t0)))
  hydra.adapt.terms.wrapToUnwrapped : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.utils.bidirectional : (∀[t0,t1].((hydra.coders.CoderDirection → t0 → (hydra.compute.Flow @ t1 @ t0)) → (hydra.compute.Coder @ t1 @ t1 @ t0 @ t0)))
  hydra.adapt.utils.chooseAdapter : (∀[t0,t1,t2,t3,t4].((t0 → (hydra.compute.Flow @ t1 @ list<(hydra.compute.Adapter @ t2 @ t3 @ t0 @ t0 @ t4 @ t4)>)) → (t0 → boolean) → (t0 → string) → (t0 → string) → t0 → (hydra.compute.Flow @ t1 @ (hydra.compute.Adapter @ t2 @ t3 @ t0 @ t0 @ t4 @ t4))))
  hydra.adapt.utils.composeCoders : (∀[t0,t1,t2,t3,t4].((hydra.compute.Coder @ t0 @ t1 @ t2 @ t3) → (hydra.compute.Coder @ t0 @ t1 @ t3 @ t4) → (hydra.compute.Coder @ t0 @ t1 @ t2 @ t4)))
  hydra.adapt.utils.encodeDecode : (∀[t0,t1].(hydra.coders.CoderDirection → (hydra.compute.Coder @ t0 @ t0 @ t1 @ t1) → t1 → (hydra.compute.Flow @ t0 @ t1)))
  hydra.adapt.utils.floatTypeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.FloatType → boolean))
  hydra.adapt.utils.idAdapter : (∀[t0,t1,t2,t3].(t0 → (hydra.compute.Adapter @ t1 @ t2 @ t0 @ t0 @ t3 @ t3)))
  hydra.adapt.utils.idCoder : (∀[t0,t1,t2].(hydra.compute.Coder @ t0 @ t1 @ t2 @ t2))
  hydra.adapt.utils.integerTypeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.IntegerType → boolean))
  hydra.adapt.utils.literalTypeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.LiteralType → boolean))
  hydra.adapt.utils.nameToFilePath : ((hydra.mantle.CaseConvention → hydra.mantle.CaseConvention → hydra.module.FileExtension → hydra.core.Name → string))
  hydra.adapt.utils.typeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.Type → boolean))
  hydra.adapt.utils.unidirectionalCoder : (∀[t0,t1,t2,t3].((t0 → (hydra.compute.Flow @ t1 @ t2)) → (hydra.compute.Coder @ t1 @ t3 @ t0 @ t2)))
  hydra.annotations.aggregateAnnotations : (∀[t0,t1,t2,t3].((t0 → optional<t1>) → (t1 → t0) → (t1 → map<t2, t3>) → t0 → map<t2, t3>))
  hydra.annotations.debugIf : (∀[t0,t1].(t0 → string → (hydra.compute.Flow @ t1 @ unit)))
  hydra.annotations.failOnFlag : (∀[t0].(hydra.core.Name → string → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.getAttr : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ optional<hydra.core.Term>)))
  hydra.annotations.getAttrWithDefault : (∀[t0].(hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.annotations.getCount : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ int32)))
  hydra.annotations.getDebugId : (∀[t0].(hydra.compute.Flow @ t0 @ optional<string>))
  hydra.annotations.getDescription : ((map<hydra.core.Name, hydra.core.Term> → (hydra.compute.Flow @ hydra.graph.Graph @ optional<string>)))
  hydra.annotations.getTermAnnotation : ((hydra.core.Name → hydra.core.Term → optional<hydra.core.Term>))
  hydra.annotations.getTermDescription : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ optional<string>)))
  hydra.annotations.getType : ((map<hydra.core.Name, hydra.core.Term> → (hydra.compute.Flow @ hydra.graph.Graph @ optional<hydra.core.Type>)))
  hydra.annotations.getTypeAnnotation : ((hydra.core.Name → hydra.core.Type → optional<hydra.core.Term>))
  hydra.annotations.getTypeClasses : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, set<hydra.mantle.TypeClass>>)))
  hydra.annotations.getTypeDescription : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ optional<string>)))
  hydra.annotations.hasDescription : (∀[t0].(map<hydra.core.Name, t0> → boolean))
  hydra.annotations.hasFlag : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ boolean)))
  hydra.annotations.hasTypeDescription : ((hydra.core.Type → boolean))
  hydra.annotations.isNativeType : ((hydra.graph.Element → boolean))
  hydra.annotations.nextCount : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ int32)))
  hydra.annotations.normalizeTermAnnotations : ((hydra.core.Term → hydra.core.Term))
  hydra.annotations.normalizeTypeAnnotations : ((hydra.core.Type → hydra.core.Type))
  hydra.annotations.putAttr : (∀[t0].(hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.putCount : (∀[t0].(hydra.core.Name → int32 → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.resetCount : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.setAnnotation : (∀[t0,t1].(t0 → optional<t1> → map<t0, t1> → map<t0, t1>))
  hydra.annotations.setDescription : ((optional<string> → map<hydra.core.Name, hydra.core.Term> → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.setTermAnnotation : ((hydra.core.Name → optional<hydra.core.Term> → hydra.core.Term → hydra.core.Term))
  hydra.annotations.setTermDescription : ((optional<string> → hydra.core.Term → hydra.core.Term))
  hydra.annotations.setType : ((optional<hydra.core.Type> → map<hydra.core.Name, hydra.core.Term> → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.setTypeAnnotation : ((hydra.core.Name → optional<hydra.core.Term> → hydra.core.Type → hydra.core.Type))
  hydra.annotations.setTypeClasses : ((map<hydra.core.Name, set<hydra.mantle.TypeClass>> → hydra.core.Term → hydra.core.Term))
  hydra.annotations.setTypeDescription : ((optional<string> → hydra.core.Type → hydra.core.Type))
  hydra.annotations.termAnnotationInternal : ((hydra.core.Term → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.typeAnnotationInternal : ((hydra.core.Type → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.typeElement : ((hydra.core.Name → hydra.core.Type → hydra.graph.Element))
  hydra.annotations.unshadowVariables : ((hydra.core.Term → hydra.core.Term))
  hydra.annotations.whenFlag : (∀[t0,t1].(hydra.core.Name → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.annotations.withDepth : (∀[t0,t1].(hydra.core.Name → (int32 → (hydra.compute.Flow @ t0 @ t1)) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.arity.functionArity : ((hydra.core.Function → int32))
  hydra.arity.primitiveArity : ((hydra.graph.Primitive → int32))
  hydra.arity.termArity : ((hydra.core.Term → int32))
  hydra.arity.typeArity : ((hydra.core.Type → int32))
  hydra.arity.uncurryType : ((hydra.core.Type → list<hydra.core.Type>))
  hydra.ast.Associativity = union{none = unit, left = unit, right = unit, both = unit}
  hydra.ast.BlockStyle = record{indent = optional<string>, newlineBeforeContent = boolean, newlineAfterContent = boolean}
  hydra.ast.BracketExpr = record{brackets = hydra.ast.Brackets, enclosed = hydra.ast.Expr, style = hydra.ast.BlockStyle}
  hydra.ast.Brackets = record{open = hydra.ast.Symbol, close = hydra.ast.Symbol}
  hydra.ast.Expr = union{const = hydra.ast.Symbol, indent = hydra.ast.IndentedExpression, op = hydra.ast.OpExpr, brackets = hydra.ast.BracketExpr}
  hydra.ast.IndentStyle = union{allLines = string, subsequentLines = string}
  hydra.ast.IndentedExpression = record{style = hydra.ast.IndentStyle, expr = hydra.ast.Expr}
  hydra.ast.Op = record{symbol = hydra.ast.Symbol, padding = hydra.ast.Padding, precedence = hydra.ast.Precedence, associativity = hydra.ast.Associativity}
  hydra.ast.OpExpr = record{op = hydra.ast.Op, lhs = hydra.ast.Expr, rhs = hydra.ast.Expr}
  hydra.ast.Padding = record{left = hydra.ast.Ws, right = hydra.ast.Ws}
  hydra.ast.Precedence = wrap[hydra.ast.Precedence](int32)
  hydra.ast.Symbol = wrap[hydra.ast.Symbol](string)
  hydra.ast.Ws = union{none = unit, space = unit, break = unit, breakAndIndent = string, doubleBreak = unit}
  hydra.coders.AdapterContext = record{graph = hydra.graph.Graph, language = hydra.coders.Language, adapters = map<hydra.core.Name, (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term)>}
  hydra.coders.CoderDirection = union{encode = unit, decode = unit}
  hydra.coders.Language = record{name = hydra.coders.LanguageName, constraints = hydra.coders.LanguageConstraints}
  hydra.coders.LanguageConstraints = record{eliminationVariants = set<hydra.mantle.EliminationVariant>, literalVariants = set<hydra.mantle.LiteralVariant>, floatTypes = set<hydra.core.FloatType>, functionVariants = set<hydra.mantle.FunctionVariant>, integerTypes = set<hydra.core.IntegerType>, termVariants = set<hydra.mantle.TermVariant>, typeVariants = set<hydra.mantle.TypeVariant>, types = (hydra.core.Type → boolean)}
  hydra.coders.LanguageName = wrap[hydra.coders.LanguageName](string)
  hydra.coders.SymmetricAdapter = (∀s.(∀t.(∀v.(hydra.compute.Adapter @ s @ s @ t @ t @ v @ v))))
  hydra.coders.TraversalOrder = union{pre = unit, post = unit}
  hydra.coders.TypeAdapter = (hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.coders.SymmetricAdapter @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Term)))
  hydra.compute.Adapter = (∀s1.(∀s2.(∀t1.(∀t2.(∀v1.(∀v2.record{isLossy = boolean, source = t1, target = t2, coder = (hydra.compute.Coder @ s1 @ s2 @ v1 @ v2)}))))))
  hydra.compute.Bicoder = (∀s1.(∀s2.(∀t1.(∀t2.(∀v1.(∀v2.record{encode = (t1 → (hydra.compute.Adapter @ s1 @ s2 @ t1 @ t2 @ v1 @ v2)), decode = (t2 → (hydra.compute.Adapter @ s2 @ s1 @ t2 @ t1 @ v2 @ v1))}))))))
  hydra.compute.Coder = (∀s1.(∀s2.(∀v1.(∀v2.record{encode = (v1 → (hydra.compute.Flow @ s1 @ v2)), decode = (v2 → (hydra.compute.Flow @ s2 @ v1))}))))
  hydra.compute.Flow = (∀s.(∀v.wrap[hydra.compute.Flow]((s → hydra.compute.Trace → (hydra.compute.FlowState @ s @ v)))))
  hydra.compute.FlowState = (∀s.(∀v.record{value = optional<v>, state = s, trace = hydra.compute.Trace}))
  hydra.compute.Trace = record{stack = list<string>, messages = list<string>, other = map<hydra.core.Name, hydra.core.Term>}
  hydra.constants.ignoredVariable : (string)
  hydra.constants.key_classes : (hydra.core.Name)
  hydra.constants.key_debugId : (hydra.core.Name)
  hydra.constants.key_deprecated : (hydra.core.Name)
  hydra.constants.key_description : (hydra.core.Name)
  hydra.constants.key_exclude : (hydra.core.Name)
  hydra.constants.key_firstClassType : (hydra.core.Name)
  hydra.constants.key_maxLength : (hydra.core.Name)
  hydra.constants.key_minLength : (hydra.core.Name)
  hydra.constants.key_preserveFieldName : (hydra.core.Name)
  hydra.constants.key_type : (hydra.core.Name)
  hydra.constants.maxInt32 : (int32)
  hydra.constants.maxTraceDepth : (int32)
  hydra.constants.placeholderName : (hydra.core.Name)
  hydra.constants.warningAutoGeneratedFile : (string)
  hydra.constraints.PathEquation = record{left = hydra.query.Path, right = hydra.query.Path}
  hydra.constraints.PatternImplication = record{antecedent = hydra.query.Pattern, consequent = hydra.query.Pattern}
  hydra.core.AnnotatedTerm = record{subject = hydra.core.Term, annotation = map<hydra.core.Name, hydra.core.Term>}
  hydra.core.AnnotatedType = record{subject = hydra.core.Type, annotation = map<hydra.core.Name, hydra.core.Term>}
  hydra.core.Application = record{function = hydra.core.Term, argument = hydra.core.Term}
  hydra.core.ApplicationType = record{function = hydra.core.Type, argument = hydra.core.Type}
  hydra.core.CaseStatement = record{typeName = hydra.core.Name, default = optional<hydra.core.Term>, cases = list<hydra.core.Field>}
  hydra.core.Elimination = union{product = hydra.core.TupleProjection, record = hydra.core.Projection, union = hydra.core.CaseStatement, wrap = hydra.core.Name}
  hydra.core.Field = record{name = hydra.core.Name, term = hydra.core.Term}
  hydra.core.FieldType = record{name = hydra.core.Name, type = hydra.core.Type}
  hydra.core.FloatType = union{bigfloat = unit, float32 = unit, float64 = unit}
  hydra.core.FloatValue = union{bigfloat = bigfloat, float32 = float32, float64 = float64}
  hydra.core.ForallType = record{parameter = hydra.core.Name, body = hydra.core.Type}
  hydra.core.Function = union{elimination = hydra.core.Elimination, lambda = hydra.core.Lambda, primitive = hydra.core.Name}
  hydra.core.FunctionType = record{domain = hydra.core.Type, codomain = hydra.core.Type}
  hydra.core.Injection = record{typeName = hydra.core.Name, field = hydra.core.Field}
  hydra.core.IntegerType = union{bigint = unit, int8 = unit, int16 = unit, int32 = unit, int64 = unit, uint8 = unit, uint16 = unit, uint32 = unit, uint64 = unit}
  hydra.core.IntegerValue = union{bigint = bigint, int8 = int8, int16 = int16, int32 = int32, int64 = int64, uint8 = uint8, uint16 = uint16, uint32 = uint32, uint64 = uint64}
  hydra.core.Lambda = record{parameter = hydra.core.Name, domain = optional<hydra.core.Type>, body = hydra.core.Term}
  hydra.core.Let = record{bindings = list<hydra.core.LetBinding>, environment = hydra.core.Term}
  hydra.core.LetBinding = record{name = hydra.core.Name, term = hydra.core.Term, type = optional<hydra.core.TypeScheme>}
  hydra.core.Literal = union{binary = binary, boolean = boolean, float = hydra.core.FloatValue, integer = hydra.core.IntegerValue, string = string}
  hydra.core.LiteralType = union{binary = unit, boolean = unit, float = hydra.core.FloatType, integer = hydra.core.IntegerType, string = unit}
  hydra.core.MapType = record{keys = hydra.core.Type, values = hydra.core.Type}
  hydra.core.Name = wrap[hydra.core.Name](string)
  hydra.core.Projection = record{typeName = hydra.core.Name, field = hydra.core.Name}
  hydra.core.Record = record{typeName = hydra.core.Name, fields = list<hydra.core.Field>}
  hydra.core.RowType = record{typeName = hydra.core.Name, fields = list<hydra.core.FieldType>}
  hydra.core.Sum = record{index = int32, size = int32, term = hydra.core.Term}
  hydra.core.Term = union{annotated = hydra.core.AnnotatedTerm, application = hydra.core.Application, function = hydra.core.Function, let = hydra.core.Let, list = list<hydra.core.Term>, literal = hydra.core.Literal, map = map<hydra.core.Term, hydra.core.Term>, optional = optional<hydra.core.Term>, product = list<hydra.core.Term>, record = hydra.core.Record, set = set<hydra.core.Term>, sum = hydra.core.Sum, typeAbstraction = hydra.core.TypeAbstraction, typeApplication = hydra.core.TypedTerm, union = hydra.core.Injection, unit = unit, variable = hydra.core.Name, wrap = hydra.core.WrappedTerm}
  hydra.core.TupleProjection = record{arity = int32, index = int32, domain = optional<list<hydra.core.Type>>}
  hydra.core.Type = union{annotated = hydra.core.AnnotatedType, application = hydra.core.ApplicationType, forall = hydra.core.ForallType, function = hydra.core.FunctionType, list = hydra.core.Type, literal = hydra.core.LiteralType, map = hydra.core.MapType, optional = hydra.core.Type, product = list<hydra.core.Type>, record = hydra.core.RowType, set = hydra.core.Type, sum = list<hydra.core.Type>, union = hydra.core.RowType, unit = unit, variable = hydra.core.Name, wrap = hydra.core.WrappedType}
  hydra.core.TypeAbstraction = record{parameter = hydra.core.Name, body = hydra.core.Term}
  hydra.core.TypeScheme = record{variables = list<hydra.core.Name>, type = hydra.core.Type}
  hydra.core.TypedTerm = record{term = hydra.core.Term, type = hydra.core.Type}
  hydra.core.WrappedTerm = record{typeName = hydra.core.Name, object = hydra.core.Term}
  hydra.core.WrappedType = record{typeName = hydra.core.Name, object = hydra.core.Type}
  hydra.decode.core.applicationType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.ApplicationType)))
  hydra.decode.core.fieldType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FieldType)))
  hydra.decode.core.fieldTypes : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.FieldType>)))
  hydra.decode.core.floatType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FloatType)))
  hydra.decode.core.forallType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.ForallType)))
  hydra.decode.core.functionType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FunctionType)))
  hydra.decode.core.integerType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.IntegerType)))
  hydra.decode.core.literalType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.LiteralType)))
  hydra.decode.core.mapType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.MapType)))
  hydra.decode.core.name : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Name)))
  hydra.decode.core.rowType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.RowType)))
  hydra.decode.core.string : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ string)))
  hydra.decode.core.type : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.decode.core.typeScheme : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.TypeScheme)))
  hydra.decode.core.wrappedType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.WrappedType)))
  hydra.decoding.bigfloat : ((hydra.core.Term → optional<bigfloat>))
  hydra.decoding.bigfloatValue : ((hydra.core.FloatValue → optional<bigfloat>))
  hydra.decoding.bigint : ((hydra.core.Term → optional<bigint>))
  hydra.decoding.bigintValue : ((hydra.core.IntegerValue → optional<bigint>))
  hydra.decoding.binary : ((hydra.core.Term → optional<binary>))
  hydra.decoding.binaryLiteral : ((hydra.core.Literal → optional<binary>))
  hydra.decoding.boolean : ((hydra.core.Term → optional<boolean>))
  hydra.decoding.booleanLiteral : ((hydra.core.Literal → optional<boolean>))
  hydra.decoding.caseField : ((hydra.core.Name → hydra.core.Name → hydra.core.Term → optional<hydra.core.Term>))
  hydra.decoding.cases : ((hydra.core.Name → hydra.core.Term → optional<list<hydra.core.Field>>))
  hydra.decoding.field : ((hydra.core.Name → list<hydra.core.Field> → optional<hydra.core.Term>))
  hydra.decoding.float32 : ((hydra.core.Term → optional<float32>))
  hydra.decoding.float32Value : ((hydra.core.FloatValue → optional<float32>))
  hydra.decoding.float64 : ((hydra.core.Term → optional<float64>))
  hydra.decoding.float64Value : ((hydra.core.FloatValue → optional<float64>))
  hydra.decoding.floatLiteral : ((hydra.core.Literal → optional<hydra.core.FloatValue>))
  hydra.decoding.int16 : ((hydra.core.Term → optional<int16>))
  hydra.decoding.int16Value : ((hydra.core.IntegerValue → optional<int16>))
  hydra.decoding.int32 : ((hydra.core.Term → optional<int32>))
  hydra.decoding.int32Value : ((hydra.core.IntegerValue → optional<int32>))
  hydra.decoding.int64 : ((hydra.core.Term → optional<int64>))
  hydra.decoding.int64Value : ((hydra.core.IntegerValue → optional<int64>))
  hydra.decoding.int8 : ((hydra.core.Term → optional<int8>))
  hydra.decoding.int8Value : ((hydra.core.IntegerValue → optional<int8>))
  hydra.decoding.integerLiteral : ((hydra.core.Literal → optional<hydra.core.IntegerValue>))
  hydra.decoding.lambda : ((hydra.core.Term → optional<hydra.core.Lambda>))
  hydra.decoding.letBinding : ((hydra.core.Name → hydra.core.Term → optional<hydra.core.LetBinding>))
  hydra.decoding.letBindingWithKey : ((hydra.core.Name → list<hydra.core.LetBinding> → optional<hydra.core.LetBinding>))
  hydra.decoding.letTerm : ((hydra.core.Term → optional<hydra.core.Let>))
  hydra.decoding.list : ((hydra.core.Term → optional<list<hydra.core.Term>>))
  hydra.decoding.literal : ((hydra.core.Term → optional<hydra.core.Literal>))
  hydra.decoding.map : ((hydra.core.Term → optional<map<hydra.core.Term, hydra.core.Term>>))
  hydra.decoding.name : ((hydra.core.Term → optional<hydra.core.Name>))
  hydra.decoding.nominal : (∀[t0,t1,t2].((t0 → hydra.core.Name) → (t0 → t1) → (t2 → optional<t0>) → hydra.core.Name → t2 → optional<t1>))
  hydra.decoding.optional : ((hydra.core.Term → optional<optional<hydra.core.Term>>))
  hydra.decoding.pair : ((hydra.core.Term → optional<hydra.core.Term×hydra.core.Term>))
  hydra.decoding.record : ((hydra.core.Name → hydra.core.Term → optional<list<hydra.core.Field>>))
  hydra.decoding.set : ((hydra.core.Term → optional<set<hydra.core.Term>>))
  hydra.decoding.string : ((hydra.core.Term → optional<string>))
  hydra.decoding.stringLiteral : ((hydra.core.Literal → optional<string>))
  hydra.decoding.uint16 : ((hydra.core.Term → optional<uint16>))
  hydra.decoding.uint16Value : ((hydra.core.IntegerValue → optional<uint16>))
  hydra.decoding.uint32 : ((hydra.core.Term → optional<uint32>))
  hydra.decoding.uint32Value : ((hydra.core.IntegerValue → optional<uint32>))
  hydra.decoding.uint64 : ((hydra.core.Term → optional<uint64>))
  hydra.decoding.uint64Value : ((hydra.core.IntegerValue → optional<uint64>))
  hydra.decoding.uint8 : ((hydra.core.Term → optional<uint8>))
  hydra.decoding.uint8Value : ((hydra.core.IntegerValue → optional<uint8>))
  hydra.decoding.unit : ((hydra.core.Term → optional<unit>))
  hydra.decoding.unitVariant : ((hydra.core.Name → hydra.core.Term → optional<hydra.core.Name>))
  hydra.decoding.variable : ((hydra.core.Term → optional<hydra.core.Name>))
  hydra.decoding.variant : ((hydra.core.Name → hydra.core.Term → optional<hydra.core.Field>))
  hydra.decoding.wrap : ((hydra.core.Name → hydra.core.Term → optional<hydra.core.Term>))
  hydra.describe.core.floatType : ((hydra.core.FloatType → string))
  hydra.describe.core.integerType : ((hydra.core.IntegerType → string))
  hydra.describe.core.literalType : ((hydra.core.LiteralType → string))
  hydra.describe.core.type : ((hydra.core.Type → string))
  hydra.describe.mantle.precision : ((hydra.mantle.Precision → string))
  hydra.encode.core.annotatedTerm : ((hydra.core.AnnotatedTerm → hydra.core.Term))
  hydra.encode.core.annotatedType : ((hydra.core.AnnotatedType → hydra.core.Term))
  hydra.encode.core.application : ((hydra.core.Application → hydra.core.Term))
  hydra.encode.core.applicationType : ((hydra.core.ApplicationType → hydra.core.Term))
  hydra.encode.core.caseStatement : ((hydra.core.CaseStatement → hydra.core.Term))
  hydra.encode.core.elimination : ((hydra.core.Elimination → hydra.core.Term))
  hydra.encode.core.field : ((hydra.core.Field → hydra.core.Term))
  hydra.encode.core.fieldType : ((hydra.core.FieldType → hydra.core.Term))
  hydra.encode.core.floatType : ((hydra.core.FloatType → hydra.core.Term))
  hydra.encode.core.floatValue : ((hydra.core.FloatValue → hydra.core.Term))
  hydra.encode.core.forallType : ((hydra.core.ForallType → hydra.core.Term))
  hydra.encode.core.function : ((hydra.core.Function → hydra.core.Term))
  hydra.encode.core.functionType : ((hydra.core.FunctionType → hydra.core.Term))
  hydra.encode.core.injection : ((hydra.core.Injection → hydra.core.Term))
  hydra.encode.core.integerType : ((hydra.core.IntegerType → hydra.core.Term))
  hydra.encode.core.integerValue : ((hydra.core.IntegerValue → hydra.core.Term))
  hydra.encode.core.isEncodedType : ((hydra.core.Term → boolean))
  hydra.encode.core.isType : ((hydra.core.Type → boolean))
  hydra.encode.core.isUnitTerm : ((hydra.core.Term → boolean))
  hydra.encode.core.isUnitType : ((hydra.core.Type → boolean))
  hydra.encode.core.lambda : ((hydra.core.Lambda → hydra.core.Term))
  hydra.encode.core.let : ((hydra.core.Let → hydra.core.Term))
  hydra.encode.core.letBinding : ((hydra.core.LetBinding → hydra.core.Term))
  hydra.encode.core.literal : ((hydra.core.Literal → hydra.core.Term))
  hydra.encode.core.literalType : ((hydra.core.LiteralType → hydra.core.Term))
  hydra.encode.core.mapType : ((hydra.core.MapType → hydra.core.Term))
  hydra.encode.core.name : ((hydra.core.Name → hydra.core.Term))
  hydra.encode.core.projection : ((hydra.core.Projection → hydra.core.Term))
  hydra.encode.core.record : ((hydra.core.Record → hydra.core.Term))
  hydra.encode.core.rowType : ((hydra.core.RowType → hydra.core.Term))
  hydra.encode.core.sum : ((hydra.core.Sum → hydra.core.Term))
  hydra.encode.core.term : ((hydra.core.Term → hydra.core.Term))
  hydra.encode.core.tupleProjection : ((hydra.core.TupleProjection → hydra.core.Term))
  hydra.encode.core.type : ((hydra.core.Type → hydra.core.Term))
  hydra.encode.core.typeAbstraction : ((hydra.core.TypeAbstraction → hydra.core.Term))
  hydra.encode.core.typeScheme : ((hydra.core.TypeScheme → hydra.core.Term))
  hydra.encode.core.typedTerm : ((hydra.core.TypedTerm → hydra.core.Term))
  hydra.encode.core.wrappedTerm : ((hydra.core.WrappedTerm → hydra.core.Term))
  hydra.encode.core.wrappedType : ((hydra.core.WrappedType → hydra.core.Term))
  hydra.extract.core.bigfloat : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ bigfloat)))
  hydra.extract.core.bigfloatValue : (∀[t0].(hydra.core.FloatValue → (hydra.compute.Flow @ t0 @ bigfloat)))
  hydra.extract.core.bigint : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ bigint)))
  hydra.extract.core.bigintValue : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ bigint)))
  hydra.extract.core.binary : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ binary)))
  hydra.extract.core.binaryLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ binary)))
  hydra.extract.core.boolean : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ boolean)))
  hydra.extract.core.booleanLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ boolean)))
  hydra.extract.core.caseField : ((hydra.core.Name → string → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Field)))
  hydra.extract.core.cases : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.CaseStatement)))
  hydra.extract.core.field : (∀[t0].(hydra.core.Name → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → list<hydra.core.Field> → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.extract.core.float32 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ float32)))
  hydra.extract.core.float32Value : (∀[t0].(hydra.core.FloatValue → (hydra.compute.Flow @ t0 @ float32)))
  hydra.extract.core.float64 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ float64)))
  hydra.extract.core.float64Value : (∀[t0].(hydra.core.FloatValue → (hydra.compute.Flow @ t0 @ float64)))
  hydra.extract.core.floatLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ hydra.core.FloatValue)))
  hydra.extract.core.floatValue : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FloatValue)))
  hydra.extract.core.functionType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.FunctionType)))
  hydra.extract.core.injection : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Field)))
  hydra.extract.core.int16 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int16)))
  hydra.extract.core.int16Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int16)))
  hydra.extract.core.int32 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int32)))
  hydra.extract.core.int32Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int32)))
  hydra.extract.core.int64 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int64)))
  hydra.extract.core.int64Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int64)))
  hydra.extract.core.int8 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int8)))
  hydra.extract.core.int8Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int8)))
  hydra.extract.core.integerLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ hydra.core.IntegerValue)))
  hydra.extract.core.integerValue : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.IntegerValue)))
  hydra.extract.core.lambda : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Lambda)))
  hydra.extract.core.lambdaBody : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.letBinding : ((string → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.letTerm : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Let)))
  hydra.extract.core.list : (∀[t0].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<t0>)))
  hydra.extract.core.listHead : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.listType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.core.literal : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Literal)))
  hydra.extract.core.map : (∀[t0,t1].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t1)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ map<t0, t1>)))
  hydra.extract.core.mapType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.MapType)))
  hydra.extract.core.nArgs : (∀[t0,t1].(hydra.core.Name → int32 → list<t0> → (hydra.compute.Flow @ t1 @ unit)))
  hydra.extract.core.optional : (∀[t0].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ optional<t0>)))
  hydra.extract.core.optionalType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.core.pair : (∀[t0,t1].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t1)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0×t1)))
  hydra.extract.core.productType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.Type>)))
  hydra.extract.core.record : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.Field>)))
  hydra.extract.core.recordType : (∀[t0].(hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.FieldType>)))
  hydra.extract.core.set : (∀[t0].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ set<t0>)))
  hydra.extract.core.setType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.core.string : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ string)))
  hydra.extract.core.stringLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ string)))
  hydra.extract.core.sumType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.Type>)))
  hydra.extract.core.uint16 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint16)))
  hydra.extract.core.uint16Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint16)))
  hydra.extract.core.uint32 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint32)))
  hydra.extract.core.uint32Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint32)))
  hydra.extract.core.uint64 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint64)))
  hydra.extract.core.uint64Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint64)))
  hydra.extract.core.uint8 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint8)))
  hydra.extract.core.uint8Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint8)))
  hydra.extract.core.unionType : (∀[t0].(hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.FieldType>)))
  hydra.extract.core.unit : (∀[t0].(hydra.core.Term → (hydra.compute.Flow @ t0 @ unit)))
  hydra.extract.core.unitVariant : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Name)))
  hydra.extract.core.variant : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Field)))
  hydra.extract.core.wrap : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.wrappedType : (∀[t0].(hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.mantle.comparison : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.mantle.Comparison)))
  hydra.formatting.capitalize : ((string → string))
  hydra.formatting.convertCase : ((hydra.mantle.CaseConvention → hydra.mantle.CaseConvention → string → string))
  hydra.formatting.convertCaseCamelToLowerSnake : ((string → string))
  hydra.formatting.convertCaseCamelToUpperSnake : ((string → string))
  hydra.formatting.convertCasePascalToUpperSnake : ((string → string))
  hydra.formatting.decapitalize : ((string → string))
  hydra.formatting.escapeWithUnderscore : ((set<string> → string → string))
  hydra.formatting.indentLines : ((string → string))
  hydra.formatting.javaStyleComment : ((string → string))
  hydra.formatting.mapFirstLetter : (((string → string) → string → string))
  hydra.formatting.nonAlnumToUnderscores : ((string → string))
  hydra.formatting.sanitizeWithUnderscores : ((set<string> → string → string))
  hydra.formatting.showList : (∀[t0].((t0 → string) → list<t0> → string))
  hydra.formatting.stripLeadingAndTrailingWhitespace : ((string → string))
  hydra.formatting.withCharacterAliases : ((string → string))
  hydra.formatting.wrapLine : ((int32 → string → string))
  hydra.grammar.Constant = wrap[hydra.grammar.Constant](string)
  hydra.grammar.Grammar = wrap[hydra.grammar.Grammar](list<hydra.grammar.Production>)
  hydra.grammar.Label = wrap[hydra.grammar.Label](string)
  hydra.grammar.LabeledPattern = record{label = hydra.grammar.Label, pattern = hydra.grammar.Pattern}
  hydra.grammar.Pattern = union{alternatives = list<hydra.grammar.Pattern>, constant = hydra.grammar.Constant, ignored = hydra.grammar.Pattern, labeled = hydra.grammar.LabeledPattern, nil = unit, nonterminal = hydra.grammar.Symbol, option = hydra.grammar.Pattern, plus = hydra.grammar.Pattern, regex = hydra.grammar.Regex, sequence = list<hydra.grammar.Pattern>, star = hydra.grammar.Pattern}
  hydra.grammar.Production = record{symbol = hydra.grammar.Symbol, pattern = hydra.grammar.Pattern}
  hydra.grammar.Regex = wrap[hydra.grammar.Regex](string)
  hydra.grammar.Symbol = wrap[hydra.grammar.Symbol](string)
  hydra.grammars.childName : ((string → string → string))
  hydra.grammars.findNames : ((list<hydra.grammar.Pattern> → list<string>))
  hydra.grammars.grammarToModule : ((hydra.module.Namespace → hydra.grammar.Grammar → optional<string> → hydra.module.Module))
  hydra.grammars.isComplex : ((hydra.grammar.Pattern → boolean))
  hydra.grammars.isNontrivial : ((boolean → list<hydra.grammar.Pattern> → boolean))
  hydra.grammars.makeElements : ((boolean → hydra.module.Namespace → string → hydra.grammar.Pattern → list<string×hydra.core.Type>))
  hydra.grammars.rawName : ((hydra.grammar.Pattern → string))
  hydra.grammars.simplify : ((boolean → list<hydra.grammar.Pattern> → list<hydra.grammar.Pattern>))
  hydra.grammars.toName : ((hydra.module.Namespace → string → hydra.core.Name))
  hydra.grammars.wrapType : ((hydra.core.Type → hydra.core.Type))
  hydra.graph.Element = record{name = hydra.core.Name, term = hydra.core.Term, type = optional<hydra.core.TypeScheme>}
  hydra.graph.Graph = record{elements = map<hydra.core.Name, hydra.graph.Element>, environment = map<hydra.core.Name, optional<hydra.core.Term>>, types = map<hydra.core.Name, hydra.core.TypeScheme>, body = hydra.core.Term, primitives = map<hydra.core.Name, hydra.graph.Primitive>, schema = optional<hydra.graph.Graph>}
  hydra.graph.Primitive = record{name = hydra.core.Name, type = hydra.core.TypeScheme, implementation = (list<hydra.core.Term> → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term))}
  hydra.graph.TermCoder = (∀a.record{type = hydra.core.Type, coder = (hydra.compute.Coder @ hydra.graph.Graph @ hydra.graph.Graph @ hydra.core.Term @ a)})
  hydra.inference.bindConstraints : (∀[t0,t1].(hydra.typing.InferenceContext → (hydra.typing.TypeSubst → (hydra.compute.Flow @ t0 @ t1)) → list<hydra.typing.TypeConstraint> → (hydra.compute.Flow @ t0 @ t1)))
  hydra.inference.checkSameType : (∀[t0].(string → list<hydra.core.Type> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.inference.checkType : (∀[t0].(set<hydra.core.Name> → hydra.typing.InferenceContext → hydra.core.Type → hydra.core.Term → (hydra.compute.Flow @ t0 @ unit)))
  hydra.inference.checkTypeVariables : (∀[t0].(hydra.typing.InferenceContext → set<hydra.core.Name> → hydra.core.Type → (hydra.compute.Flow @ t0 @ unit)))
  hydra.inference.debugInference : (boolean)
  hydra.inference.emptyInferenceContext : (hydra.typing.InferenceContext)
  hydra.inference.extendContext : ((list<hydra.core.Name×hydra.core.TypeScheme> → hydra.typing.InferenceContext → hydra.typing.InferenceContext))
  hydra.inference.fTypeToTypeScheme : ((hydra.core.Type → hydra.core.TypeScheme))
  hydra.inference.forInferredTerm : (∀[t0,t1].(hydra.typing.InferenceContext → hydra.core.Term → string → (hydra.typing.InferenceResult → t0) → (hydra.compute.Flow @ t1 @ t0)))
  hydra.inference.forVar : (∀[t0,t1].((hydra.core.Name → t0) → (hydra.compute.Flow @ t1 @ t0)))
  hydra.inference.forVars : (∀[t0,t1].(int32 → (list<hydra.core.Name> → t0) → (hydra.compute.Flow @ t1 @ t0)))
  hydra.inference.freeVariablesInContext : ((hydra.typing.InferenceContext → set<hydra.core.Name>))
  hydra.inference.freshName : (∀[t0].(hydra.compute.Flow @ t0 @ hydra.core.Name))
  hydra.inference.freshNames : (∀[t0].(int32 → (hydra.compute.Flow @ t0 @ list<hydra.core.Name>)))
  hydra.inference.freshVariableType : (∀[t0].(hydra.compute.Flow @ t0 @ hydra.core.Type))
  hydra.inference.gatherForall : ((list<hydra.core.Name> → hydra.core.Type → hydra.core.TypeScheme))
  hydra.inference.generalize : ((hydra.typing.InferenceContext → hydra.core.Type → hydra.core.TypeScheme))
  hydra.inference.graphToInferenceContext : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceContext)))
  hydra.inference.inferGraphTypes : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ hydra.graph.Graph)))
  hydra.inference.inferInGraphContext : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.typing.InferenceResult)))
  hydra.inference.inferMany : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Term×string> → (hydra.compute.Flow @ t0 @ list<hydra.core.Term>×list<hydra.core.Type>×hydra.typing.TypeSubst)))
  hydra.inference.inferTypeOf : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term×hydra.core.TypeScheme)))
  hydra.inference.inferTypeOfAnnotatedTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.AnnotatedTerm → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfApplication : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Application → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfCaseStatement : (∀[t0].(hydra.typing.InferenceContext → hydra.core.CaseStatement → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfCollection : (∀[t0].(hydra.typing.InferenceContext → (hydra.core.Type → hydra.core.Type) → (list<hydra.core.Term> → hydra.core.Term) → string → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfElimination : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Elimination → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfFunction : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Function → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfInjection : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Injection → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLambda : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Lambda → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLet : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Let → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLetAfterNormalization : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Let → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfList : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLiteral : (∀[t0,t1].(t0 → hydra.core.Literal → (hydra.compute.Flow @ t1 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfMap : (∀[t0].(hydra.typing.InferenceContext → map<hydra.core.Term, hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfOptional : (∀[t0].(hydra.typing.InferenceContext → optional<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfPrimitive : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfProduct : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfProjection : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Projection → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfRecord : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Record → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfSet : (∀[t0].(hydra.typing.InferenceContext → set<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfSum : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Sum → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term → string → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTupleProjection : (∀[t0,t1].(t0 → hydra.core.TupleProjection → (hydra.compute.Flow @ t1 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTypeAbstraction : (∀[t0].(hydra.typing.InferenceContext → hydra.core.TypeAbstraction → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTypeApplication : (∀[t0].(hydra.typing.InferenceContext → hydra.core.TypedTerm → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfUnit : (hydra.typing.InferenceResult)
  hydra.inference.inferTypeOfUnwrap : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfVariable : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfWrappedTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.WrappedTerm → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypesOfTemporaryLetBindings : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.LetBinding> → (hydra.compute.Flow @ t0 @ list<hydra.core.Term>×list<hydra.core.Type>×hydra.typing.TypeSubst)))
  hydra.inference.instantiateTypeScheme : (∀[t0].(hydra.core.TypeScheme → (hydra.compute.Flow @ t0 @ hydra.core.TypeScheme)))
  hydra.inference.isUnbound : ((hydra.typing.InferenceContext → hydra.core.Name → boolean))
  hydra.inference.key_vcount : (hydra.core.Name)
  hydra.inference.mapConstraints : (∀[t0,t1].(hydra.typing.InferenceContext → (hydra.typing.TypeSubst → t0) → list<hydra.typing.TypeConstraint> → (hydra.compute.Flow @ t1 @ t0)))
  hydra.inference.nominalApplication : ((hydra.core.Name → list<hydra.core.Type> → hydra.core.Type))
  hydra.inference.normalTypeVariable : ((int32 → hydra.core.Name))
  hydra.inference.requireSchemaType : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.core.TypeScheme)))
  hydra.inference.showInferenceResult : ((hydra.typing.InferenceResult → string))
  hydra.inference.toFContext : ((hydra.typing.InferenceContext → map<hydra.core.Name, hydra.core.Type>))
  hydra.inference.typeOf : (∀[t0].(hydra.typing.InferenceContext → set<hydra.core.Name> → map<hydra.core.Name, hydra.core.Type> → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.inference.typeOfCollection : (∀[t0].(hydra.typing.InferenceContext → string → (hydra.core.Type → hydra.core.Type) → set<hydra.core.Name> → map<hydra.core.Name, hydra.core.Type> → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.inference.typeOfNominal : (∀[t0].(string → hydra.typing.InferenceContext → hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.inference.typeSchemeToFType : ((hydra.core.TypeScheme → hydra.core.Type))
  hydra.inference.yield : ((hydra.core.Term → hydra.core.Type → hydra.typing.TypeSubst → hydra.typing.InferenceResult))
  hydra.inference.yieldChecked : (∀[t0,t1,t2].(t0 → t1 → hydra.core.Term → hydra.core.Type → hydra.typing.TypeSubst → (hydra.compute.Flow @ t2 @ hydra.typing.InferenceResult)))
  hydra.inference.yieldDebug : (∀[t0,t1,t2].(t0 → t1 → hydra.core.Term → hydra.core.Type → hydra.typing.TypeSubst → (hydra.compute.Flow @ t2 @ hydra.typing.InferenceResult)))
  hydra.json.Value = union{array = list<hydra.json.Value>, boolean = boolean, null = unit, number = bigfloat, object = map<string, hydra.json.Value>, string = string}
  hydra.languages.hydraLanguage : (hydra.coders.Language)
  hydra.lexical.dereferenceElement : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ optional<hydra.graph.Element>)))
  hydra.lexical.elementsToGraph : ((hydra.graph.Graph → optional<hydra.graph.Graph> → list<hydra.graph.Element> → hydra.graph.Graph))
  hydra.lexical.emptyGraph : (hydra.graph.Graph)
  hydra.lexical.extendGraphWithBindings : ((list<hydra.core.LetBinding> → hydra.graph.Graph → hydra.graph.Graph))
  hydra.lexical.fieldsOf : ((hydra.core.Type → list<hydra.core.FieldType>))
  hydra.lexical.getField : (∀[t0,t1,t2].(map<hydra.core.Name, t0> → hydra.core.Name → (t0 → (hydra.compute.Flow @ t1 @ t2)) → (hydra.compute.Flow @ t1 @ t2)))
  hydra.lexical.lookupElement : ((hydra.graph.Graph → hydra.core.Name → optional<hydra.graph.Element>))
  hydra.lexical.lookupPrimitive : ((hydra.graph.Graph → hydra.core.Name → optional<hydra.graph.Primitive>))
  hydra.lexical.matchEnum : (∀[t0].(hydra.core.Name → list<hydra.core.Name×t0> → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.lexical.matchRecord : (∀[t0,t1].((map<hydra.core.Name, hydra.core.Term> → (hydra.compute.Flow @ t0 @ t1)) → hydra.core.Term → (hydra.compute.Flow @ t0 @ t1)))
  hydra.lexical.matchUnion : (∀[t0].(hydra.core.Name → list<hydra.core.Name×(hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0))> → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.lexical.matchUnitField : (∀[t0,t1,t2,t3].(t0 → t1 → t0×(t2 → (hydra.compute.Flow @ t3 @ t1))))
  hydra.lexical.requireElement : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.graph.Element)))
  hydra.lexical.requirePrimitive : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.graph.Primitive)))
  hydra.lexical.requireTerm : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.lexical.resolveTerm : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ optional<hydra.core.Term>)))
  hydra.lexical.schemaContext : ((hydra.graph.Graph → hydra.graph.Graph))
  hydra.lexical.stripAndDereferenceTerm : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.lexical.typeOfPrimitive : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.TypeScheme)))
  hydra.lexical.withEmptyGraph : (∀[t0,t1].((hydra.compute.Flow @ hydra.graph.Graph @ t0) → (hydra.compute.Flow @ t1 @ t0)))
  hydra.lexical.withSchemaContext : (∀[t0].((hydra.compute.Flow @ hydra.graph.Graph @ t0) → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.literals.floatValueToBigfloat : ((hydra.core.FloatValue → bigfloat))
  hydra.literals.integerValueToBigint : ((hydra.core.IntegerValue → bigint))
  hydra.mantle.CaseConvention = union{camel = unit, pascal = unit, lowerSnake = unit, upperSnake = unit}
  hydra.mantle.Comparison = union{lessThan = unit, equalTo = unit, greaterThan = unit}
  hydra.mantle.Either = (∀a.(∀b.union{left = a, right = b}))
  hydra.mantle.EliminationVariant = union{product = unit, record = unit, union = unit, wrap = unit}
  hydra.mantle.FunctionVariant = union{elimination = unit, lambda = unit, primitive = unit}
  hydra.mantle.LiteralVariant = union{binary = unit, boolean = unit, float = unit, integer = unit, string = unit}
  hydra.mantle.Precision = union{arbitrary = unit, bits = int32}
  hydra.mantle.TermVariant = union{annotated = unit, application = unit, function = unit, let = unit, list = unit, literal = unit, map = unit, optional = unit, product = unit, record = unit, set = unit, sum = unit, typeAbstraction = unit, typeApplication = unit, union = unit, unit = unit, variable = unit, wrap = unit}
  hydra.mantle.TypeClass = union{equality = unit, ordering = unit}
  hydra.mantle.TypeVariant = union{annotated = unit, application = unit, forall = unit, function = unit, list = unit, literal = unit, map = unit, optional = unit, product = unit, record = unit, set = unit, sum = unit, union = unit, unit = unit, variable = unit, wrap = unit}
  hydra.module.Definition = union{term = hydra.module.TermDefinition, type = hydra.module.TypeDefinition}
  hydra.module.FileExtension = wrap[hydra.module.FileExtension](string)
  hydra.module.Library = record{namespace = hydra.module.Namespace, prefix = string, primitives = list<hydra.graph.Primitive>}
  hydra.module.Module = record{namespace = hydra.module.Namespace, elements = list<hydra.graph.Element>, termDependencies = list<hydra.module.Module>, typeDependencies = list<hydra.module.Module>, description = optional<string>}
  hydra.module.Namespace = wrap[hydra.module.Namespace](string)
  hydra.module.Namespaces = (∀n.record{focus = hydra.module.Namespace×n, mapping = map<hydra.module.Namespace, n>})
  hydra.module.QualifiedName = record{namespace = optional<hydra.module.Namespace>, local = string}
  hydra.module.TermDefinition = record{name = hydra.core.Name, term = hydra.core.Term, type = hydra.core.Type}
  hydra.module.TypeDefinition = record{name = hydra.core.Name, type = hydra.core.Type}
  hydra.monads.bind : (∀[t0,t1,t2].((hydra.compute.Flow @ t0 @ t1) → (t1 → (hydra.compute.Flow @ t0 @ t2)) → (hydra.compute.Flow @ t0 @ t2)))
  hydra.monads.emptyTrace : (hydra.compute.Trace)
  hydra.monads.exec : (∀[t0,t1].((hydra.compute.Flow @ t0 @ t1) → t0 → t0))
  hydra.monads.fail : (∀[t0,t1].(string → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.flowSucceeds : (∀[t0,t1].(t0 → (hydra.compute.Flow @ t0 @ t1) → boolean))
  hydra.monads.fromFlow : (∀[t0,t1].(t0 → t1 → (hydra.compute.Flow @ t1 @ t0) → t0))
  hydra.monads.getState : (∀[t0].(hydra.compute.Flow @ t0 @ t0))
  hydra.monads.map : (∀[t0,t1,t2].((t0 → t1) → (hydra.compute.Flow @ t2 @ t0) → (hydra.compute.Flow @ t2 @ t1)))
  hydra.monads.map2 : (∀[t0,t1,t2,t3].((hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t2) → (t1 → t2 → t3) → (hydra.compute.Flow @ t0 @ t3)))
  hydra.monads.modify : (∀[t0].((t0 → t0) → (hydra.compute.Flow @ t0 @ unit)))
  hydra.monads.mutateTrace : (∀[t0,t1].((hydra.compute.Trace → (hydra.mantle.Either @ string @ hydra.compute.Trace)) → (hydra.compute.Trace → hydra.compute.Trace → hydra.compute.Trace) → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.optionalToList : (∀[t0].(optional<t0> → list<t0>))
  hydra.monads.pure : (∀[t0,t1].(t0 → (hydra.compute.Flow @ t1 @ t0)))
  hydra.monads.pushError : ((string → hydra.compute.Trace → hydra.compute.Trace))
  hydra.monads.putState : (∀[t0].(t0 → (hydra.compute.Flow @ t0 @ unit)))
  hydra.monads.traceSummary : ((hydra.compute.Trace → string))
  hydra.monads.unexpected : (∀[t0,t1].(string → string → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.warn : (∀[t0,t1].(string → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.withFlag : (∀[t0,t1].(hydra.core.Name → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.withState : (∀[t0,t1,t2].(t0 → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t2 @ t1)))
  hydra.monads.withTrace : (∀[t0,t1].(string → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.names.compactName : ((map<hydra.module.Namespace, string> → hydra.core.Name → string))
  hydra.names.localNameOf : ((hydra.core.Name → string))
  hydra.names.namespaceOf : ((hydra.core.Name → optional<hydra.module.Namespace>))
  hydra.names.namespaceToFilePath : ((hydra.mantle.CaseConvention → hydra.module.FileExtension → hydra.module.Namespace → string))
  hydra.names.qname : ((hydra.module.Namespace → string → hydra.core.Name))
  hydra.names.qualifyName : ((hydra.core.Name → hydra.module.QualifiedName))
  hydra.names.uniqueLabel : ((set<string> → string → string))
  hydra.names.unqualifyName : ((hydra.module.QualifiedName → hydra.core.Name))
  hydra.phantoms.TElement = (∀a.record{name = hydra.core.Name, term = (hydra.phantoms.TTerm @ a)})
  hydra.phantoms.TTerm = (∀a.wrap[hydra.phantoms.TTerm](hydra.core.Term))
  hydra.query.ComparisonConstraint = union{equal = unit, notEqual = unit, lessThan = unit, greaterThan = unit, lessThanOrEqual = unit, greaterThanOrEqual = unit}
  hydra.query.Edge = record{type = hydra.core.Name, out = optional<hydra.core.Name>, in = optional<hydra.core.Name>}
  hydra.query.GraphPattern = record{graph = hydra.core.Name, patterns = list<hydra.query.Pattern>}
  hydra.query.Node = union{term = hydra.core.Term, variable = hydra.query.Variable, wildcard = unit}
  hydra.query.Path = union{step = hydra.query.Step, regex = hydra.query.RegexSequence, inverse = hydra.query.Path}
  hydra.query.Pattern = union{triple = hydra.query.TriplePattern, negation = hydra.query.Pattern, conjunction = list<hydra.query.Pattern>, disjunction = list<hydra.query.Pattern>, graph = hydra.query.GraphPattern}
  hydra.query.Query = record{variables = list<hydra.query.Variable>, patterns = list<hydra.query.Pattern>}
  hydra.query.Range = record{min = int32, max = int32}
  hydra.query.RegexQuantifier = union{one = unit, zeroOrOne = unit, zeroOrMore = unit, oneOrMore = unit, exactly = int32, atLeast = int32, range = hydra.query.Range}
  hydra.query.RegexSequence = record{path = hydra.query.Path, quantifier = hydra.query.RegexQuantifier}
  hydra.query.Step = union{edge = hydra.query.Edge, project = hydra.core.Projection, compare = hydra.query.ComparisonConstraint}
  hydra.query.TriplePattern = record{subject = hydra.query.Node, predicate = hydra.query.Path, object = hydra.query.Node}
  hydra.query.Variable = wrap[hydra.query.Variable](string)
  hydra.reduction.alphaConvert : ((hydra.core.Name → hydra.core.Term → hydra.core.Term → hydra.core.Term))
  hydra.reduction.betaReduceType : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.reduction.contractTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.reduction.countPrimitiveInvocations : (boolean)
  hydra.reduction.etaReduceTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.reduction.expandLambdas : ((hydra.graph.Graph → hydra.core.Term → hydra.core.Term))
  hydra.reduction.expansionArity : ((hydra.graph.Graph → hydra.core.Term → int32))
  hydra.reduction.reduceTerm : ((boolean → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.reduction.termIsClosed : ((hydra.core.Term → boolean))
  hydra.reduction.termIsValue : (∀[t0].(t0 → hydra.core.Term → boolean))
  hydra.relational.ColumnName = wrap[hydra.relational.ColumnName](string)
  hydra.relational.ColumnSchema = (∀t.record{name = hydra.relational.ColumnName, domain = t})
  hydra.relational.ForeignKey = record{foreignRelation = hydra.relational.RelationName, keys = map<hydra.relational.ColumnName, hydra.relational.ColumnName>}
  hydra.relational.PrimaryKey = wrap[hydra.relational.PrimaryKey](list<hydra.relational.ColumnName>)
  hydra.relational.Relation = (∀v.wrap[hydra.relational.Relation](list<(hydra.relational.Row @ v)>))
  hydra.relational.RelationName = wrap[hydra.relational.RelationName](string)
  hydra.relational.RelationSchema = (∀t.record{name = hydra.relational.RelationName, columns = list<(hydra.relational.ColumnSchema @ t)>, primaryKeys = list<hydra.relational.PrimaryKey>, foreignKeys = list<hydra.relational.ForeignKey>})
  hydra.relational.Relationship = (∀v.wrap[hydra.relational.Relationship](set<map<hydra.relational.ColumnName, v>>))
  hydra.relational.Row = (∀v.wrap[hydra.relational.Row](list<v>))
  hydra.rewriting.deannotateAndDetypeTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.deannotateTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.deannotateType : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.deannotateTypeParameters : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.deannotateTypeRecursive : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.deannotateTypeSchemeRecursive : ((hydra.core.TypeScheme → hydra.core.TypeScheme))
  hydra.rewriting.expandTypedLambdas : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.flattenLetTerms : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.foldOverTerm : (∀[t0].(hydra.coders.TraversalOrder → (t0 → hydra.core.Term → t0) → t0 → hydra.core.Term → t0))
  hydra.rewriting.foldOverType : (∀[t0].(hydra.coders.TraversalOrder → (t0 → hydra.core.Type → t0) → t0 → hydra.core.Type → t0))
  hydra.rewriting.freeVariablesInTerm : ((hydra.core.Term → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInType : ((hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeOrdered : ((hydra.core.Type → list<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeScheme : ((hydra.core.TypeScheme → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeSchemeSimple : ((hydra.core.TypeScheme → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeSimple : ((hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.inlineType : (∀[t0].(map<hydra.core.Name, hydra.core.Type> → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.rewriting.isFreeVariableInTerm : ((hydra.core.Name → hydra.core.Term → boolean))
  hydra.rewriting.isLambda : ((hydra.core.Term → boolean))
  hydra.rewriting.mapBeneathTypeAnnotations : (((hydra.core.Type → hydra.core.Type) → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.normalizeTypeVariablesInTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.removeTermAnnotations : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.removeTypeAnnotations : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.removeTypesFromTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.replaceFreeName : ((hydra.core.Name → hydra.core.Type → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.rewrite : (∀[t0,t1].((t0 → t1) → (t1 → t0) → t0))
  hydra.rewriting.rewriteTerm : ((((hydra.core.Term → hydra.core.Term) → hydra.core.Term → hydra.core.Term) → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.rewriteTermM : (∀[t0].(((hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)) → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)) → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.rewriting.rewriteType : ((((hydra.core.Type → hydra.core.Type) → hydra.core.Type → hydra.core.Type) → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.rewriteTypeM : (∀[t0].(((hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)) → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)) → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.rewriting.simplifyTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.substituteTypeVariables : ((map<hydra.core.Name, hydra.core.Name> → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.substituteVariable : ((hydra.core.Name → hydra.core.Name → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.substituteVariables : ((map<hydra.core.Name, hydra.core.Name> → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.subterms : ((hydra.core.Term → list<hydra.core.Term>))
  hydra.rewriting.subtermsWithAccessors : ((hydra.core.Term → list<hydra.accessors.TermAccessor×hydra.core.Term>))
  hydra.rewriting.subtypes : ((hydra.core.Type → list<hydra.core.Type>))
  hydra.rewriting.termDependencyNames : ((boolean → boolean → boolean → hydra.core.Term → set<hydra.core.Name>))
  hydra.rewriting.toShortNames : ((list<hydra.core.Name> → map<hydra.core.Name, hydra.core.Name>))
  hydra.rewriting.topologicalSortBindings : ((map<hydra.core.Name, hydra.core.Term> → list<list<hydra.core.Name×hydra.core.Term>>))
  hydra.rewriting.topologicalSortElements : ((list<hydra.graph.Element> → (hydra.mantle.Either @ list<list<hydra.core.Name>> @ list<hydra.core.Name>)))
  hydra.rewriting.typeDependencyNames : ((boolean → hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.typeNamesInType : ((hydra.core.Type → set<hydra.core.Name>))
  hydra.schemas.definitionDependencyNamespaces : ((list<hydra.module.Definition> → set<hydra.module.Namespace>))
  hydra.schemas.dependencyNamespaces : ((boolean → boolean → boolean → boolean → list<hydra.graph.Element> → (hydra.compute.Flow @ hydra.graph.Graph @ set<hydra.module.Namespace>)))
  hydra.schemas.dereferenceType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ optional<hydra.core.Type>)))
  hydra.schemas.elementAsTypedTerm : (∀[t0].(hydra.graph.Element → (hydra.compute.Flow @ t0 @ hydra.core.TypedTerm)))
  hydra.schemas.elementsWithDependencies : ((list<hydra.graph.Element> → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.graph.Element>)))
  hydra.schemas.fieldTypes : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.schemas.findFieldType : (∀[t0].(hydra.core.Name → list<hydra.core.FieldType> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.schemas.fullyStripType : ((hydra.core.Type → hydra.core.Type))
  hydra.schemas.isEnumRowType : ((hydra.core.RowType → boolean))
  hydra.schemas.isEnumType : ((hydra.core.Type → boolean))
  hydra.schemas.isSerializable : ((hydra.graph.Element → (hydra.compute.Flow @ hydra.graph.Graph @ boolean)))
  hydra.schemas.moduleDependencyNamespaces : ((boolean → boolean → boolean → boolean → hydra.module.Module → (hydra.compute.Flow @ hydra.graph.Graph @ set<hydra.module.Namespace>)))
  hydra.schemas.namespacesForDefinitions : (∀[t0].((hydra.module.Namespace → t0) → hydra.module.Namespace → list<hydra.module.Definition> → (hydra.module.Namespaces @ t0)))
  hydra.schemas.requireRecordType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.RowType)))
  hydra.schemas.requireRowType : (∀[t0].(string → (hydra.core.Type → optional<t0>) → hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.schemas.requireType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.schemas.requireUnionType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.RowType)))
  hydra.schemas.resolveType : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ optional<hydra.core.Type>)))
  hydra.schemas.schemaGraphToTypingEnvironment : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ map<hydra.core.Name, hydra.core.TypeScheme>)))
  hydra.schemas.topologicalSortTypeDefinitions : ((list<hydra.module.TypeDefinition> → list<list<hydra.module.TypeDefinition>>))
  hydra.schemas.typeDependencies : ((boolean → (hydra.core.Type → hydra.core.Type) → hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.serialization.angleBraces : (hydra.ast.Brackets)
  hydra.serialization.angleBracesList : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.bracesListAdaptive : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.bracketList : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.bracketListAdaptive : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.brackets : ((hydra.ast.Brackets → hydra.ast.BlockStyle → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.commaSep : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.cst : ((string → hydra.ast.Expr))
  hydra.serialization.curlyBlock : ((hydra.ast.BlockStyle → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.curlyBraces : (hydra.ast.Brackets)
  hydra.serialization.curlyBracesList : ((optional<string> → hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.customIndent : ((string → string → string))
  hydra.serialization.customIndentBlock : ((string → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.dotSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.doubleNewlineSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.doubleSpace : (string)
  hydra.serialization.expressionLength : ((hydra.ast.Expr → int32))
  hydra.serialization.fullBlockStyle : (hydra.ast.BlockStyle)
  hydra.serialization.halfBlockStyle : (hydra.ast.BlockStyle)
  hydra.serialization.ifx : ((hydra.ast.Op → hydra.ast.Expr → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.indent : ((string → string))
  hydra.serialization.indentBlock : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.indentSubsequentLines : ((string → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.infixWs : ((string → hydra.ast.Expr → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.infixWsList : ((string → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.inlineStyle : (hydra.ast.BlockStyle)
  hydra.serialization.newlineSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.noPadding : (hydra.ast.Padding)
  hydra.serialization.noSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.num : ((int32 → hydra.ast.Expr))
  hydra.serialization.op : ((string → int32 → hydra.ast.Associativity → hydra.ast.Op))
  hydra.serialization.orOp : ((boolean → hydra.ast.Op))
  hydra.serialization.orSep : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.parenList : ((boolean → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.parens : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.parentheses : (hydra.ast.Brackets)
  hydra.serialization.parenthesize : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.prefix : ((string → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.printExpr : ((hydra.ast.Expr → string))
  hydra.serialization.semicolonSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.sep : ((hydra.ast.Op → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.spaceSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.squareBrackets : (hydra.ast.Brackets)
  hydra.serialization.sym : ((string → hydra.ast.Symbol))
  hydra.serialization.symbolSep : ((string → hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.tabIndent : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.tabIndentDoubleSpace : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.tabIndentSingleSpace : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.unsupportedType : ((string → hydra.ast.Expr))
  hydra.serialization.unsupportedVariant : ((string → string → hydra.ast.Expr))
  hydra.serialization.withComma : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.withSemi : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.show.accessors.termAccessor : ((hydra.accessors.TermAccessor → optional<string>))
  hydra.show.accessors.termToAccessorGraph : ((map<hydra.module.Namespace, string> → hydra.core.Term → hydra.accessors.AccessorGraph))
  hydra.show.core.float : ((hydra.core.FloatValue → string))
  hydra.show.core.floatType : ((hydra.core.FloatType → string))
  hydra.show.core.integer : ((hydra.core.IntegerValue → string))
  hydra.show.core.integerType : ((hydra.core.IntegerType → string))
  hydra.show.core.list : (∀[t0].((t0 → string) → list<t0> → string))
  hydra.show.core.literal : ((hydra.core.Literal → string))
  hydra.show.core.literalType : ((hydra.core.LiteralType → string))
  hydra.show.core.readTerm : (∀[t0,t1].(t0 → optional<t1>))
  hydra.show.core.term : ((hydra.core.Term → string))
  hydra.show.core.typeScheme : ((hydra.core.TypeScheme → string))
  hydra.show.core.type_ : ((hydra.core.Type → string))
  hydra.show.graph.element : ((hydra.graph.Element → string))
  hydra.show.graph.graph : ((hydra.graph.Graph → string))
  hydra.show.mantle.termVariant : ((hydra.mantle.TermVariant → string))
  hydra.show.mantle.typeVariant : ((hydra.mantle.TypeVariant → string))
  hydra.show.typing.typeConstraint : ((hydra.typing.TypeConstraint → string))
  hydra.show.typing.typeSubst : ((hydra.typing.TypeSubst → string))
  hydra.sorting.createOrderingIsomorphism : (∀[t0,t1].(list<t0> → list<t0> → (hydra.topology.OrderingIsomorphism @ t1)))
  hydra.sorting.topologicalSort : (∀[t0].(list<t0×list<t0>> → (hydra.mantle.Either @ list<list<t0>> @ list<t0>)))
  hydra.sorting.topologicalSortComponents : (∀[t0].(list<t0×list<t0>> → list<list<t0>>))
  hydra.substitution.composeTypeSubst : ((hydra.typing.TypeSubst → hydra.typing.TypeSubst → hydra.typing.TypeSubst))
  hydra.substitution.composeTypeSubstList : ((list<hydra.typing.TypeSubst> → hydra.typing.TypeSubst))
  hydra.substitution.idTypeSubst : (hydra.typing.TypeSubst)
  hydra.substitution.singletonTypeSubst : ((hydra.core.Name → hydra.core.Type → hydra.typing.TypeSubst))
  hydra.substitution.substInContext : ((hydra.typing.TypeSubst → hydra.typing.InferenceContext → hydra.typing.InferenceContext))
  hydra.substitution.substInType : ((hydra.typing.TypeSubst → hydra.core.Type → hydra.core.Type))
  hydra.substitution.substInTypeScheme : ((hydra.typing.TypeSubst → hydra.core.TypeScheme → hydra.core.TypeScheme))
  hydra.substitution.substTypesInTerm : ((hydra.typing.TypeSubst → hydra.core.Term → hydra.core.Term))
  hydra.substitution.substituteInConstraint : ((hydra.typing.TypeSubst → hydra.typing.TypeConstraint → hydra.typing.TypeConstraint))
  hydra.substitution.substituteInConstraints : ((hydra.typing.TypeSubst → list<hydra.typing.TypeConstraint> → list<hydra.typing.TypeConstraint>))
  hydra.substitution.substituteInTerm : ((hydra.typing.TermSubst → hydra.core.Term → hydra.core.Term))
  hydra.tabular.DataRow = (∀v.wrap[hydra.tabular.DataRow](list<optional<v>>))
  hydra.tabular.HeaderRow = wrap[hydra.tabular.HeaderRow](list<string>)
  hydra.tabular.Table = (∀v.record{header = optional<hydra.tabular.HeaderRow>, data = list<(hydra.tabular.DataRow @ v)>})
  hydra.tarjan.adjacencyListsToGraph : (∀[t0].(list<t0×list<t0>> → map<int32, list<int32>>×(int32 → t0)))
  hydra.tarjan.initialState : (hydra.topology.TarjanState)
  hydra.tarjan.popStackUntil : ((int32 → (hydra.compute.Flow @ hydra.topology.TarjanState @ list<int32>)))
  hydra.tarjan.strongConnect : ((map<int32, list<int32>> → int32 → (hydra.compute.Flow @ hydra.topology.TarjanState @ unit)))
  hydra.tarjan.stronglyConnectedComponents : ((map<int32, list<int32>> → list<list<int32>>))
  hydra.templates.graphToSchema : ((hydra.graph.Graph → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.templates.instantiateTemplate : (∀[t0].(boolean → map<hydra.core.Name, hydra.core.Type> → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.testing.CaseConversionTestCase = record{fromConvention = hydra.mantle.CaseConvention, toConvention = hydra.mantle.CaseConvention, fromString = string, toString = string}
  hydra.testing.EvaluationStyle = union{eager = unit, lazy = unit}
  hydra.testing.EvaluationTestCase = record{evaluationStyle = hydra.testing.EvaluationStyle, input = hydra.core.Term, output = hydra.core.Term}
  hydra.testing.InferenceTestCase = record{input = hydra.core.Term, output = hydra.core.TypeScheme}
  hydra.testing.Tag = wrap[hydra.testing.Tag](string)
  hydra.testing.TestCase = union{caseConversion = hydra.testing.CaseConversionTestCase, evaluation = hydra.testing.EvaluationTestCase, inference = hydra.testing.InferenceTestCase}
  hydra.testing.TestCaseWithMetadata = record{name = string, case = hydra.testing.TestCase, description = optional<string>, tags = list<hydra.testing.Tag>}
  hydra.testing.TestGroup = record{name = string, description = optional<string>, subgroups = list<hydra.testing.TestGroup>, cases = list<hydra.testing.TestCaseWithMetadata>}
  hydra.topology.Graph = map<hydra.topology.Vertex, list<hydra.topology.Vertex>>
  hydra.topology.OrderingIsomorphism = (∀a.record{encode = (list<a> → list<a>), decode = (list<a> → list<a>)})
  hydra.topology.TarjanState = record{counter = int32, indices = map<hydra.topology.Vertex, int32>, lowLinks = map<hydra.topology.Vertex, int32>, stack = list<hydra.topology.Vertex>, onStack = set<hydra.topology.Vertex>, sccs = list<list<hydra.topology.Vertex>>}
  hydra.topology.Vertex = int32
  hydra.typing.InferenceContext = record{schemaTypes = map<hydra.core.Name, hydra.core.TypeScheme>, primitiveTypes = map<hydra.core.Name, hydra.core.TypeScheme>, dataTypes = map<hydra.core.Name, hydra.core.TypeScheme>, debug = boolean}
  hydra.typing.InferenceResult = record{term = hydra.core.Term, type = hydra.core.Type, subst = hydra.typing.TypeSubst}
  hydra.typing.TermSubst = wrap[hydra.typing.TermSubst](map<hydra.core.Name, hydra.core.Term>)
  hydra.typing.TypeConstraint = record{left = hydra.core.Type, right = hydra.core.Type, comment = string}
  hydra.typing.TypeSubst = wrap[hydra.typing.TypeSubst](map<hydra.core.Name, hydra.core.Type>)
  hydra.unification.joinTypes : (∀[t0].(hydra.core.Type → hydra.core.Type → string → (hydra.compute.Flow @ t0 @ list<hydra.typing.TypeConstraint>)))
  hydra.unification.unifyTypeConstraints : (∀[t0,t1].(map<hydra.core.Name, t0> → list<hydra.typing.TypeConstraint> → (hydra.compute.Flow @ t1 @ hydra.typing.TypeSubst)))
  hydra.unification.unifyTypeLists : (∀[t0,t1].(map<hydra.core.Name, t0> → list<hydra.core.Type> → list<hydra.core.Type> → string → (hydra.compute.Flow @ t1 @ hydra.typing.TypeSubst)))
  hydra.unification.unifyTypes : (∀[t0,t1].(map<hydra.core.Name, t0> → hydra.core.Type → hydra.core.Type → string → (hydra.compute.Flow @ t1 @ hydra.typing.TypeSubst)))
  hydra.unification.variableOccursInType : ((hydra.core.Name → hydra.core.Type → boolean))
  hydra.variants.eliminationVariant : ((hydra.core.Elimination → hydra.mantle.EliminationVariant))
  hydra.variants.eliminationVariants : (list<hydra.mantle.EliminationVariant>)
  hydra.variants.fieldMap : ((list<hydra.core.Field> → map<hydra.core.Name, hydra.core.Term>))
  hydra.variants.fieldTypeMap : ((list<hydra.core.FieldType> → map<hydra.core.Name, hydra.core.Type>))
  hydra.variants.floatTypePrecision : ((hydra.core.FloatType → hydra.mantle.Precision))
  hydra.variants.floatTypes : (list<hydra.core.FloatType>)
  hydra.variants.floatValueType : ((hydra.core.FloatValue → hydra.core.FloatType))
  hydra.variants.functionVariant : ((hydra.core.Function → hydra.mantle.FunctionVariant))
  hydra.variants.functionVariants : (list<hydra.mantle.FunctionVariant>)
  hydra.variants.integerTypeIsSigned : ((hydra.core.IntegerType → boolean))
  hydra.variants.integerTypePrecision : ((hydra.core.IntegerType → hydra.mantle.Precision))
  hydra.variants.integerTypes : (list<hydra.core.IntegerType>)
  hydra.variants.integerValueType : ((hydra.core.IntegerValue → hydra.core.IntegerType))
  hydra.variants.literalType : ((hydra.core.Literal → hydra.core.LiteralType))
  hydra.variants.literalTypeVariant : ((hydra.core.LiteralType → hydra.mantle.LiteralVariant))
  hydra.variants.literalVariant : ((hydra.core.Literal → hydra.mantle.LiteralVariant))
  hydra.variants.literalVariants : (list<hydra.mantle.LiteralVariant>)
  hydra.variants.termVariant : ((hydra.core.Term → hydra.mantle.TermVariant))
  hydra.variants.termVariants : (list<hydra.mantle.TermVariant>)
  hydra.variants.typeVariant : ((hydra.core.Type → hydra.mantle.TypeVariant))
  hydra.variants.typeVariants : (list<hydra.mantle.TypeVariant>)
  hydra.workflow.HydraSchemaSpec = record{modules = list<hydra.module.Module>, typeName = hydra.core.Name}
  hydra.workflow.LastMile = (∀s.(∀a.record{encoder = (hydra.core.Type → (hydra.compute.Flow @ s @ (hydra.core.Term → hydra.graph.Graph → (hydra.compute.Flow @ s @ list<a>)))), serializer = (list<a> → (hydra.compute.Flow @ s @ string)), fileExtension = string}))
  hydra.workflow.SchemaSpec = union{hydra = hydra.workflow.HydraSchemaSpec, file = string, provided = unit}
  hydra.workflow.TransformWorkflow = record{name = string, schemaSpec = hydra.workflow.SchemaSpec, srcDir = string, destDir = string}

Primitives:
  hydra.lib.chars.isAlphaNum : ((int32 → boolean))
  hydra.lib.chars.isLower : ((int32 → boolean))
  hydra.lib.chars.isSpace : ((int32 → boolean))
  hydra.lib.chars.isUpper : ((int32 → boolean))
  hydra.lib.chars.toLower : ((int32 → int32))
  hydra.lib.chars.toUpper : ((int32 → int32))
  hydra.lib.equality.compare : (∀[x].(x → x → hydra.mantle.Comparison))
  hydra.lib.equality.equal : (∀[x].(x → x → boolean))
  hydra.lib.equality.gt : (∀[x].(x → x → boolean))
  hydra.lib.equality.gte : (∀[x].(x → x → boolean))
  hydra.lib.equality.identity : (∀[x].(x → x))
  hydra.lib.equality.lt : (∀[x].(x → x → boolean))
  hydra.lib.equality.lte : (∀[x].(x → x → boolean))
  hydra.lib.equality.max : (∀[x].(x → x → x))
  hydra.lib.equality.min : (∀[x].(x → x → x))
  hydra.lib.flows.apply : (∀[s,x,y].((hydra.compute.Flow @ s @ (x → y)) → (hydra.compute.Flow @ s @ x) → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.bind : (∀[s,x,y].((hydra.compute.Flow @ s @ x) → (x → (hydra.compute.Flow @ s @ y)) → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.fail : (∀[s,x].(string → (hydra.compute.Flow @ s @ x)))
  hydra.lib.flows.map : (∀[s,x,y].((x → y) → (hydra.compute.Flow @ s @ x) → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.mapList : (∀[s,x,y].((x → (hydra.compute.Flow @ s @ y)) → list<x> → (hydra.compute.Flow @ s @ list<y>)))
  hydra.lib.flows.pure : (∀[s,x].(x → (hydra.compute.Flow @ s @ x)))
  hydra.lib.flows.sequence : (∀[s,x].(list<(hydra.compute.Flow @ s @ x)> → (hydra.compute.Flow @ s @ list<x>)))
  hydra.lib.flows.traverseOptional : (∀[s,x,y].((x → (hydra.compute.Flow @ s @ y)) → optional<x> → (hydra.compute.Flow @ s @ optional<y>)))
  hydra.lib.lists.apply : (∀[x,y].(list<(x → y)> → list<x> → list<y>))
  hydra.lib.lists.at : (∀[x].(int32 → list<x> → x))
  hydra.lib.lists.bind : (∀[x,y].(list<x> → (x → list<y>) → list<y>))
  hydra.lib.lists.concat : (∀[x].(list<list<x>> → list<x>))
  hydra.lib.lists.concat2 : (∀[x].(list<x> → list<x> → list<x>))
  hydra.lib.lists.cons : (∀[x].(x → list<x> → list<x>))
  hydra.lib.lists.drop : (∀[x].(int32 → list<x> → list<x>))
  hydra.lib.lists.dropWhile : (∀[x].((x → boolean) → list<x> → list<x>))
  hydra.lib.lists.elem : (∀[x].(x → list<x> → boolean))
  hydra.lib.lists.filter : (∀[x].((x → boolean) → list<x> → list<x>))
  hydra.lib.lists.foldl : (∀[x,y].((y → x → y) → y → list<x> → y))
  hydra.lib.lists.group : (∀[x].(list<x> → list<list<x>>))
  hydra.lib.lists.head : (∀[x].(list<x> → x))
  hydra.lib.lists.init : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.intercalate : (∀[x].(list<x> → list<list<x>> → list<x>))
  hydra.lib.lists.intersperse : (∀[x].(x → list<x> → list<x>))
  hydra.lib.lists.last : (∀[x].(list<x> → x))
  hydra.lib.lists.length : (∀[x].(list<x> → int32))
  hydra.lib.lists.map : (∀[x,y].((x → y) → list<x> → list<y>))
  hydra.lib.lists.nub : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.null : (∀[x].(list<x> → boolean))
  hydra.lib.lists.pure : (∀[x].(x → list<x>))
  hydra.lib.lists.replicate : (∀[x].(int32 → x → list<x>))
  hydra.lib.lists.reverse : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.safeHead : (∀[x].(list<x> → optional<x>))
  hydra.lib.lists.singleton : (∀[x].(x → list<x>))
  hydra.lib.lists.sort : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.sortOn : (∀[x,y].((x → y) → list<x> → list<x>))
  hydra.lib.lists.span : (∀[x,y].((x → boolean) → list<x> → list<x>×list<x>))
  hydra.lib.lists.tail : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.take : (∀[x].(int32 → list<x> → list<x>))
  hydra.lib.lists.transpose : (∀[x].(list<list<x>> → list<list<x>>))
  hydra.lib.lists.zip : (∀[x,y].(list<x> → list<y> → list<x×y>))
  hydra.lib.lists.zipWith : (∀[x,y,z].((x → y → z) → list<x> → list<y> → list<z>))
  hydra.lib.literals.bigfloatToBigint : ((bigfloat → bigint))
  hydra.lib.literals.bigfloatToFloat32 : ((bigfloat → float32))
  hydra.lib.literals.bigfloatToFloat64 : ((bigfloat → float64))
  hydra.lib.literals.bigintToBigfloat : ((bigint → bigfloat))
  hydra.lib.literals.bigintToInt16 : ((bigint → int16))
  hydra.lib.literals.bigintToInt32 : ((bigint → int32))
  hydra.lib.literals.bigintToInt64 : ((bigint → int64))
  hydra.lib.literals.bigintToInt8 : ((bigint → int8))
  hydra.lib.literals.bigintToUint16 : ((bigint → uint16))
  hydra.lib.literals.bigintToUint32 : ((bigint → uint32))
  hydra.lib.literals.bigintToUint64 : ((bigint → uint64))
  hydra.lib.literals.bigintToUint8 : ((bigint → uint8))
  hydra.lib.literals.binaryToString : ((binary → string))
  hydra.lib.literals.float32ToBigfloat : ((float32 → bigfloat))
  hydra.lib.literals.float64ToBigfloat : ((float64 → bigfloat))
  hydra.lib.literals.int16ToBigint : ((int16 → bigint))
  hydra.lib.literals.int32ToBigint : ((int32 → bigint))
  hydra.lib.literals.int64ToBigint : ((int64 → bigint))
  hydra.lib.literals.int8ToBigint : ((int8 → bigint))
  hydra.lib.literals.readBigfloat : ((string → optional<bigfloat>))
  hydra.lib.literals.readBoolean : ((string → optional<boolean>))
  hydra.lib.literals.readFloat32 : ((string → optional<float32>))
  hydra.lib.literals.readFloat64 : ((string → optional<float64>))
  hydra.lib.literals.readInt32 : ((string → optional<int32>))
  hydra.lib.literals.readInt64 : ((string → optional<int64>))
  hydra.lib.literals.readString : ((string → optional<string>))
  hydra.lib.literals.show : ((boolean → string))
  hydra.lib.literals.showBigfloat : ((bigfloat → string))
  hydra.lib.literals.showBigint : ((bigint → string))
  hydra.lib.literals.showFloat32 : ((float32 → string))
  hydra.lib.literals.showFloat64 : ((float64 → string))
  hydra.lib.literals.showInt16 : ((int16 → string))
  hydra.lib.literals.showInt32 : ((int32 → string))
  hydra.lib.literals.showInt64 : ((int64 → string))
  hydra.lib.literals.showInt8 : ((int8 → string))
  hydra.lib.literals.showString : ((string → string))
  hydra.lib.literals.showUint16 : ((uint16 → string))
  hydra.lib.literals.showUint32 : ((uint32 → string))
  hydra.lib.literals.showUint64 : ((uint64 → string))
  hydra.lib.literals.showUint8 : ((uint8 → string))
  hydra.lib.literals.stringToBinary : ((string → binary))
  hydra.lib.literals.uint16ToBigint : ((uint16 → bigint))
  hydra.lib.literals.uint32ToBigint : ((uint32 → bigint))
  hydra.lib.literals.uint64ToBigint : ((uint64 → bigint))
  hydra.lib.literals.uint8ToBigint : ((uint8 → bigint))
  hydra.lib.logic.and : ((boolean → boolean → boolean))
  hydra.lib.logic.ifElse : (∀[x].(boolean → x → x → x))
  hydra.lib.logic.not : ((boolean → boolean))
  hydra.lib.logic.or : ((boolean → boolean → boolean))
  hydra.lib.maps.alter : (∀[k,v].((optional<v> → optional<v>) → k → map<k, v> → map<k, v>))
  hydra.lib.maps.bimap : (∀[k1,k2,v1,v2].((k1 → k2) → (v1 → v2) → map<k1, v1> → map<k2, v2>))
  hydra.lib.maps.elems : (∀[k,v].(map<k, v> → list<v>))
  hydra.lib.maps.empty : (∀[k,v].map<k, v>)
  hydra.lib.maps.filter : (∀[k,v].((v → boolean) → map<k, v> → map<k, v>))
  hydra.lib.maps.filterWithKey : (∀[k,v].((k → v → boolean) → map<k, v> → map<k, v>))
  hydra.lib.maps.findWithDefault : (∀[k,v].(v → k → map<k, v> → v))
  hydra.lib.maps.fromList : (∀[k,v].(list<k×v> → map<k, v>))
  hydra.lib.maps.insert : (∀[k,v].(k → v → map<k, v> → map<k, v>))
  hydra.lib.maps.keys : (∀[k,v].(map<k, v> → list<k>))
  hydra.lib.maps.lookup : (∀[k,v].(k → map<k, v> → optional<v>))
  hydra.lib.maps.map : (∀[k,v1,v2].((v1 → v2) → map<k, v1> → map<k, v2>))
  hydra.lib.maps.mapKeys : (∀[k1,k2,v].((k1 → k2) → map<k1, v> → map<k2, v>))
  hydra.lib.maps.member : (∀[k,v].(k → map<k, v> → boolean))
  hydra.lib.maps.null : (∀[k,v].(map<k, v> → boolean))
  hydra.lib.maps.remove : (∀[k,v].(k → map<k, v> → map<k, v>))
  hydra.lib.maps.singleton : (∀[k,v].(k → v → map<k, v>))
  hydra.lib.maps.size : (∀[k,v].(map<k, v> → int32))
  hydra.lib.maps.toList : (∀[k,v].(map<k, v> → list<k×v>))
  hydra.lib.maps.union : (∀[k,v].(map<k, v> → map<k, v> → map<k, v>))
  hydra.lib.math.add : ((int32 → int32 → int32))
  hydra.lib.math.div : ((int32 → int32 → int32))
  hydra.lib.math.mod : ((int32 → int32 → int32))
  hydra.lib.math.mul : ((int32 → int32 → int32))
  hydra.lib.math.neg : ((int32 → int32))
  hydra.lib.math.range : ((int32 → int32 → list<int32>))
  hydra.lib.math.rem : ((int32 → int32 → int32))
  hydra.lib.math.sub : ((int32 → int32 → int32))
  hydra.lib.optionals.apply : (∀[x,y].(optional<(x → y)> → optional<x> → optional<y>))
  hydra.lib.optionals.bind : (∀[x,y].(optional<x> → (x → optional<y>) → optional<y>))
  hydra.lib.optionals.cases : (∀[x,y].(optional<x> → y → (x → y) → y))
  hydra.lib.optionals.cat : (∀[x].(list<optional<x>> → list<x>))
  hydra.lib.optionals.compose : (∀[x,y,z].((x → optional<y>) → (y → optional<z>) → x → optional<z>))
  hydra.lib.optionals.fromJust : (∀[x].(optional<x> → x))
  hydra.lib.optionals.fromMaybe : (∀[x].(x → optional<x> → x))
  hydra.lib.optionals.isJust : (∀[x].(optional<x> → boolean))
  hydra.lib.optionals.isNothing : (∀[x].(optional<x> → boolean))
  hydra.lib.optionals.map : (∀[x,y].((x → y) → optional<x> → optional<y>))
  hydra.lib.optionals.mapMaybe : (∀[x,y].((x → optional<y>) → list<x> → list<y>))
  hydra.lib.optionals.maybe : (∀[x,y].(y → (x → y) → optional<x> → y))
  hydra.lib.optionals.pure : (∀[x].(x → optional<x>))
  hydra.lib.sets.delete : (∀[x].(x → set<x> → set<x>))
  hydra.lib.sets.difference : (∀[x].(set<x> → set<x> → set<x>))
  hydra.lib.sets.empty : (∀[x].set<x>)
  hydra.lib.sets.fromList : (∀[x].(list<x> → set<x>))
  hydra.lib.sets.insert : (∀[x].(x → set<x> → set<x>))
  hydra.lib.sets.intersection : (∀[x].(set<x> → set<x> → set<x>))
  hydra.lib.sets.map : (∀[x,y].((x → y) → set<x> → set<y>))
  hydra.lib.sets.member : (∀[x].(x → set<x> → boolean))
  hydra.lib.sets.null : (∀[x].(set<x> → boolean))
  hydra.lib.sets.singleton : (∀[x].(x → set<x>))
  hydra.lib.sets.size : (∀[x].(set<x> → int32))
  hydra.lib.sets.toList : (∀[x].(set<x> → list<x>))
  hydra.lib.sets.union : (∀[x].(set<x> → set<x> → set<x>))
  hydra.lib.sets.unions : (∀[x].(list<set<x>> → set<x>))
  hydra.lib.strings.cat : ((list<string> → string))
  hydra.lib.strings.cat2 : ((string → string → string))
  hydra.lib.strings.charAt : ((int32 → string → int32))
  hydra.lib.strings.fromList : ((list<int32> → string))
  hydra.lib.strings.intercalate : ((string → list<string> → string))
  hydra.lib.strings.length : ((string → int32))
  hydra.lib.strings.lines : ((string → list<string>))
  hydra.lib.strings.null : ((string → boolean))
  hydra.lib.strings.splitOn : ((string → string → list<string>))
  hydra.lib.strings.toList : ((string → list<int32>))
  hydra.lib.strings.toLower : ((string → string))
  hydra.lib.strings.toUpper : ((string → string))
  hydra.lib.strings.unlines : ((list<string> → string))