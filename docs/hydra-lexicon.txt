Primitives:
  hydra.lib.chars.isAlphaNum : ((int32 → boolean))
  hydra.lib.chars.isLower : ((int32 → boolean))
  hydra.lib.chars.isSpace : ((int32 → boolean))
  hydra.lib.chars.isUpper : ((int32 → boolean))
  hydra.lib.chars.toLower : ((int32 → int32))
  hydra.lib.chars.toUpper : ((int32 → int32))
  hydra.lib.eithers.either : (∀[x,y,z].((x → z) → (y → z) → either<x, y> → z))
  hydra.lib.eithers.fromLeft : (∀[x,y].(x → either<x, y> → x))
  hydra.lib.eithers.fromRight : (∀[x,y].(y → either<x, y> → y))
  hydra.lib.eithers.isLeft : (∀[x,y].(either<x, y> → boolean))
  hydra.lib.eithers.isRight : (∀[x,y].(either<x, y> → boolean))
  hydra.lib.eithers.lefts : (∀[x,y].(list<either<x, y>> → list<x>))
  hydra.lib.eithers.partitionEithers : (∀[x,y].(list<either<x, y>> → list<x>×list<y>))
  hydra.lib.eithers.rights : (∀[x,y].(list<either<x, y>> → list<y>))
  hydra.lib.equality.compare : (∀[x].(x → x → hydra.util.Comparison))
  hydra.lib.equality.equal : (∀[x].(x → x → boolean))
  hydra.lib.equality.gt : (∀[x].(x → x → boolean))
  hydra.lib.equality.gte : (∀[x].(x → x → boolean))
  hydra.lib.equality.identity : (∀[x].(x → x))
  hydra.lib.equality.lt : (∀[x].(x → x → boolean))
  hydra.lib.equality.lte : (∀[x].(x → x → boolean))
  hydra.lib.equality.max : (∀[x].(x → x → x))
  hydra.lib.equality.min : (∀[x].(x → x → x))
  hydra.lib.flows.apply : (∀[s,x,y].((hydra.compute.Flow @ s @ (x → y)) → (hydra.compute.Flow @ s @ x) → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.bind : (∀[s,x,y].((hydra.compute.Flow @ s @ x) → (x → (hydra.compute.Flow @ s @ y)) → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.fail : (∀[s,x].(string → (hydra.compute.Flow @ s @ x)))
  hydra.lib.flows.foldl : (∀[y,x,s].((y → x → (hydra.compute.Flow @ s @ y)) → y → list<x> → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.map : (∀[x,y,s].((x → y) → (hydra.compute.Flow @ s @ x) → (hydra.compute.Flow @ s @ y)))
  hydra.lib.flows.mapElems : (∀[v1,s,v2,k].((v1 → (hydra.compute.Flow @ s @ v2)) → map<k, v1> → (hydra.compute.Flow @ s @ map<k, v2>)))
  hydra.lib.flows.mapKeys : (∀[k1,s,k2,v].((k1 → (hydra.compute.Flow @ s @ k2)) → map<k1, v> → (hydra.compute.Flow @ s @ map<k2, v>)))
  hydra.lib.flows.mapList : (∀[x,s,y].((x → (hydra.compute.Flow @ s @ y)) → list<x> → (hydra.compute.Flow @ s @ list<y>)))
  hydra.lib.flows.mapMaybe : (∀[x,s,y].((x → (hydra.compute.Flow @ s @ y)) → maybe<x> → (hydra.compute.Flow @ s @ maybe<y>)))
  hydra.lib.flows.mapSet : (∀[x,s,y].((x → (hydra.compute.Flow @ s @ y)) → set<x> → (hydra.compute.Flow @ s @ set<y>)))
  hydra.lib.flows.pure : (∀[x,s].(x → (hydra.compute.Flow @ s @ x)))
  hydra.lib.flows.sequence : (∀[s,x].(list<(hydra.compute.Flow @ s @ x)> → (hydra.compute.Flow @ s @ list<x>)))
  hydra.lib.lists.apply : (∀[x,y].(list<(x → y)> → list<x> → list<y>))
  hydra.lib.lists.at : (∀[x].(int32 → list<x> → x))
  hydra.lib.lists.bind : (∀[x,y].(list<x> → (x → list<y>) → list<y>))
  hydra.lib.lists.concat : (∀[x].(list<list<x>> → list<x>))
  hydra.lib.lists.concat2 : (∀[x].(list<x> → list<x> → list<x>))
  hydra.lib.lists.cons : (∀[x].(x → list<x> → list<x>))
  hydra.lib.lists.drop : (∀[x].(int32 → list<x> → list<x>))
  hydra.lib.lists.dropWhile : (∀[x].((x → boolean) → list<x> → list<x>))
  hydra.lib.lists.elem : (∀[x].(x → list<x> → boolean))
  hydra.lib.lists.filter : (∀[x].((x → boolean) → list<x> → list<x>))
  hydra.lib.lists.foldl : (∀[y,x].((y → x → y) → y → list<x> → y))
  hydra.lib.lists.group : (∀[x].(list<x> → list<list<x>>))
  hydra.lib.lists.head : (∀[x].(list<x> → x))
  hydra.lib.lists.init : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.intercalate : (∀[x].(list<x> → list<list<x>> → list<x>))
  hydra.lib.lists.intersperse : (∀[x].(x → list<x> → list<x>))
  hydra.lib.lists.last : (∀[x].(list<x> → x))
  hydra.lib.lists.length : (∀[x].(list<x> → int32))
  hydra.lib.lists.map : (∀[x,y].((x → y) → list<x> → list<y>))
  hydra.lib.lists.nub : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.null : (∀[x].(list<x> → boolean))
  hydra.lib.lists.pure : (∀[x].(x → list<x>))
  hydra.lib.lists.replicate : (∀[x].(int32 → x → list<x>))
  hydra.lib.lists.reverse : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.safeHead : (∀[x].(list<x> → maybe<x>))
  hydra.lib.lists.singleton : (∀[x].(x → list<x>))
  hydra.lib.lists.sort : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.sortOn : (∀[x,y].((x → y) → list<x> → list<x>))
  hydra.lib.lists.span : (∀[x].((x → boolean) → list<x> → list<x>×list<x>))
  hydra.lib.lists.tail : (∀[x].(list<x> → list<x>))
  hydra.lib.lists.take : (∀[x].(int32 → list<x> → list<x>))
  hydra.lib.lists.transpose : (∀[x].(list<list<x>> → list<list<x>>))
  hydra.lib.lists.zip : (∀[x,y].(list<x> → list<y> → list<x×y>))
  hydra.lib.lists.zipWith : (∀[x,y,z].((x → y → z) → list<x> → list<y> → list<z>))
  hydra.lib.literals.bigfloatToBigint : ((bigfloat → bigint))
  hydra.lib.literals.bigfloatToFloat32 : ((bigfloat → float32))
  hydra.lib.literals.bigfloatToFloat64 : ((bigfloat → float64))
  hydra.lib.literals.bigintToBigfloat : ((bigint → bigfloat))
  hydra.lib.literals.bigintToInt16 : ((bigint → int16))
  hydra.lib.literals.bigintToInt32 : ((bigint → int32))
  hydra.lib.literals.bigintToInt64 : ((bigint → int64))
  hydra.lib.literals.bigintToInt8 : ((bigint → int8))
  hydra.lib.literals.bigintToUint16 : ((bigint → uint16))
  hydra.lib.literals.bigintToUint32 : ((bigint → uint32))
  hydra.lib.literals.bigintToUint64 : ((bigint → uint64))
  hydra.lib.literals.bigintToUint8 : ((bigint → uint8))
  hydra.lib.literals.binaryToString : ((binary → string))
  hydra.lib.literals.float32ToBigfloat : ((float32 → bigfloat))
  hydra.lib.literals.float64ToBigfloat : ((float64 → bigfloat))
  hydra.lib.literals.int16ToBigint : ((int16 → bigint))
  hydra.lib.literals.int32ToBigint : ((int32 → bigint))
  hydra.lib.literals.int64ToBigint : ((int64 → bigint))
  hydra.lib.literals.int8ToBigint : ((int8 → bigint))
  hydra.lib.literals.readBigfloat : ((string → maybe<bigfloat>))
  hydra.lib.literals.readBoolean : ((string → maybe<boolean>))
  hydra.lib.literals.readFloat32 : ((string → maybe<float32>))
  hydra.lib.literals.readFloat64 : ((string → maybe<float64>))
  hydra.lib.literals.readInt32 : ((string → maybe<int32>))
  hydra.lib.literals.readInt64 : ((string → maybe<int64>))
  hydra.lib.literals.readString : ((string → maybe<string>))
  hydra.lib.literals.show : ((boolean → string))
  hydra.lib.literals.showBigfloat : ((bigfloat → string))
  hydra.lib.literals.showBigint : ((bigint → string))
  hydra.lib.literals.showFloat32 : ((float32 → string))
  hydra.lib.literals.showFloat64 : ((float64 → string))
  hydra.lib.literals.showInt16 : ((int16 → string))
  hydra.lib.literals.showInt32 : ((int32 → string))
  hydra.lib.literals.showInt64 : ((int64 → string))
  hydra.lib.literals.showInt8 : ((int8 → string))
  hydra.lib.literals.showString : ((string → string))
  hydra.lib.literals.showUint16 : ((uint16 → string))
  hydra.lib.literals.showUint32 : ((uint32 → string))
  hydra.lib.literals.showUint64 : ((uint64 → string))
  hydra.lib.literals.showUint8 : ((uint8 → string))
  hydra.lib.literals.stringToBinary : ((string → binary))
  hydra.lib.literals.uint16ToBigint : ((uint16 → bigint))
  hydra.lib.literals.uint32ToBigint : ((uint32 → bigint))
  hydra.lib.literals.uint64ToBigint : ((uint64 → bigint))
  hydra.lib.literals.uint8ToBigint : ((uint8 → bigint))
  hydra.lib.logic.and : ((boolean → boolean → boolean))
  hydra.lib.logic.ifElse : (∀[x].(boolean → x → x → x))
  hydra.lib.logic.not : ((boolean → boolean))
  hydra.lib.logic.or : ((boolean → boolean → boolean))
  hydra.lib.maps.alter : (∀[v,k].((maybe<v> → maybe<v>) → k → map<k, v> → map<k, v>))
  hydra.lib.maps.bimap : (∀[k1,k2,v1,v2].((k1 → k2) → (v1 → v2) → map<k1, v1> → map<k2, v2>))
  hydra.lib.maps.elems : (∀[k,v].(map<k, v> → list<v>))
  hydra.lib.maps.empty : (∀[k,v].map<k, v>)
  hydra.lib.maps.filter : (∀[v,k].((v → boolean) → map<k, v> → map<k, v>))
  hydra.lib.maps.filterWithKey : (∀[k,v].((k → v → boolean) → map<k, v> → map<k, v>))
  hydra.lib.maps.findWithDefault : (∀[v,k].(v → k → map<k, v> → v))
  hydra.lib.maps.fromList : (∀[k,v].(list<k×v> → map<k, v>))
  hydra.lib.maps.insert : (∀[k,v].(k → v → map<k, v> → map<k, v>))
  hydra.lib.maps.keys : (∀[k,v].(map<k, v> → list<k>))
  hydra.lib.maps.lookup : (∀[k,v].(k → map<k, v> → maybe<v>))
  hydra.lib.maps.map : (∀[v1,v2,k].((v1 → v2) → map<k, v1> → map<k, v2>))
  hydra.lib.maps.mapKeys : (∀[k1,k2,v].((k1 → k2) → map<k1, v> → map<k2, v>))
  hydra.lib.maps.member : (∀[k,v].(k → map<k, v> → boolean))
  hydra.lib.maps.null : (∀[k,v].(map<k, v> → boolean))
  hydra.lib.maps.remove : (∀[k,v].(k → map<k, v> → map<k, v>))
  hydra.lib.maps.singleton : (∀[k,v].(k → v → map<k, v>))
  hydra.lib.maps.size : (∀[k,v].(map<k, v> → int32))
  hydra.lib.maps.toList : (∀[k,v].(map<k, v> → list<k×v>))
  hydra.lib.maps.union : (∀[k,v].(map<k, v> → map<k, v> → map<k, v>))
  hydra.lib.math.abs : ((int32 → int32))
  hydra.lib.math.acos : ((float64 → float64))
  hydra.lib.math.acosh : ((float64 → float64))
  hydra.lib.math.add : ((int32 → int32 → int32))
  hydra.lib.math.asin : ((float64 → float64))
  hydra.lib.math.asinh : ((float64 → float64))
  hydra.lib.math.atan : ((float64 → float64))
  hydra.lib.math.atan2 : ((float64 → float64 → float64))
  hydra.lib.math.atanh : ((float64 → float64))
  hydra.lib.math.ceiling : ((float64 → bigint))
  hydra.lib.math.cos : ((float64 → float64))
  hydra.lib.math.cosh : ((float64 → float64))
  hydra.lib.math.div : ((int32 → int32 → int32))
  hydra.lib.math.e : (float64)
  hydra.lib.math.even : ((int32 → boolean))
  hydra.lib.math.exp : ((float64 → float64))
  hydra.lib.math.floor : ((float64 → bigint))
  hydra.lib.math.log : ((float64 → float64))
  hydra.lib.math.logBase : ((float64 → float64 → float64))
  hydra.lib.math.mod : ((int32 → int32 → int32))
  hydra.lib.math.mul : ((int32 → int32 → int32))
  hydra.lib.math.negate : ((int32 → int32))
  hydra.lib.math.odd : ((int32 → boolean))
  hydra.lib.math.pi : (float64)
  hydra.lib.math.pow : ((float64 → float64 → float64))
  hydra.lib.math.pred : ((int32 → int32))
  hydra.lib.math.range : ((int32 → int32 → list<int32>))
  hydra.lib.math.rem : ((int32 → int32 → int32))
  hydra.lib.math.round : ((float64 → bigint))
  hydra.lib.math.signum : ((int32 → int32))
  hydra.lib.math.sin : ((float64 → float64))
  hydra.lib.math.sinh : ((float64 → float64))
  hydra.lib.math.sqrt : ((float64 → float64))
  hydra.lib.math.sub : ((int32 → int32 → int32))
  hydra.lib.math.succ : ((int32 → int32))
  hydra.lib.math.tan : ((float64 → float64))
  hydra.lib.math.tanh : ((float64 → float64))
  hydra.lib.math.truncate : ((float64 → bigint))
  hydra.lib.maybes.apply : (∀[x,y].(maybe<(x → y)> → maybe<x> → maybe<y>))
  hydra.lib.maybes.bind : (∀[x,y].(maybe<x> → (x → maybe<y>) → maybe<y>))
  hydra.lib.maybes.cases : (∀[x,y].(maybe<x> → y → (x → y) → y))
  hydra.lib.maybes.cat : (∀[x].(list<maybe<x>> → list<x>))
  hydra.lib.maybes.compose : (∀[x,y,z].((x → maybe<y>) → (y → maybe<z>) → x → maybe<z>))
  hydra.lib.maybes.fromJust : (∀[x].(maybe<x> → x))
  hydra.lib.maybes.fromMaybe : (∀[x].(x → maybe<x> → x))
  hydra.lib.maybes.isJust : (∀[x].(maybe<x> → boolean))
  hydra.lib.maybes.isNothing : (∀[x].(maybe<x> → boolean))
  hydra.lib.maybes.map : (∀[x,y].((x → y) → maybe<x> → maybe<y>))
  hydra.lib.maybes.mapMaybe : (∀[x,y].((x → maybe<y>) → list<x> → list<y>))
  hydra.lib.maybes.maybe : (∀[y,x].(y → (x → y) → maybe<x> → y))
  hydra.lib.maybes.pure : (∀[x].(x → maybe<x>))
  hydra.lib.pairs.first : (∀[a,b].((a, b) → a))
  hydra.lib.pairs.second : (∀[a,b].((a, b) → b))
  hydra.lib.sets.delete : (∀[x].(x → set<x> → set<x>))
  hydra.lib.sets.difference : (∀[x].(set<x> → set<x> → set<x>))
  hydra.lib.sets.empty : (∀[x].set<x>)
  hydra.lib.sets.fromList : (∀[x].(list<x> → set<x>))
  hydra.lib.sets.insert : (∀[x].(x → set<x> → set<x>))
  hydra.lib.sets.intersection : (∀[x].(set<x> → set<x> → set<x>))
  hydra.lib.sets.map : (∀[x,y].((x → y) → set<x> → set<y>))
  hydra.lib.sets.member : (∀[x].(x → set<x> → boolean))
  hydra.lib.sets.null : (∀[x].(set<x> → boolean))
  hydra.lib.sets.singleton : (∀[x].(x → set<x>))
  hydra.lib.sets.size : (∀[x].(set<x> → int32))
  hydra.lib.sets.toList : (∀[x].(set<x> → list<x>))
  hydra.lib.sets.union : (∀[x].(set<x> → set<x> → set<x>))
  hydra.lib.sets.unions : (∀[x].(list<set<x>> → set<x>))
  hydra.lib.strings.cat : ((list<string> → string))
  hydra.lib.strings.cat2 : ((string → string → string))
  hydra.lib.strings.charAt : ((int32 → string → int32))
  hydra.lib.strings.fromList : ((list<int32> → string))
  hydra.lib.strings.intercalate : ((string → list<string> → string))
  hydra.lib.strings.length : ((string → int32))
  hydra.lib.strings.lines : ((string → list<string>))
  hydra.lib.strings.null : ((string → boolean))
  hydra.lib.strings.splitOn : ((string → string → list<string>))
  hydra.lib.strings.toList : ((string → list<int32>))
  hydra.lib.strings.toLower : ((string → string))
  hydra.lib.strings.toUpper : ((string → string))
  hydra.lib.strings.unlines : ((list<string> → string))
  hydra.lib.tuples.curry : (∀[a,b,c].((a×b → c) → a → b → c))
  hydra.lib.tuples.fst : (∀[a,b].(a×b → a))
  hydra.lib.tuples.snd : (∀[a,b].(a×b → b))
  hydra.lib.tuples.uncurry : (∀[a,b,c].((a → b → c) → a×b → c))

Types:
  hydra.accessors.AccessorEdge = record{source:hydra.accessors.AccessorNode, path:hydra.accessors.AccessorPath, target:hydra.accessors.AccessorNode}
  hydra.accessors.AccessorGraph = record{nodes:list<hydra.accessors.AccessorNode>, edges:list<hydra.accessors.AccessorEdge>}
  hydra.accessors.AccessorNode = record{name:hydra.core.Name, label:string, id:string}
  hydra.accessors.AccessorPath = wrap[hydra.accessors.AccessorPath](list<hydra.accessors.TermAccessor>)
  hydra.accessors.TermAccessor = union{annotatedBody:unit, applicationFunction:unit, applicationArgument:unit, lambdaBody:unit, unionCasesDefault:unit, unionCasesBranch:hydra.core.Name, letBody:unit, letBinding:hydra.core.Name, listElement:int32, mapKey:int32, mapValue:int32, maybeTerm:unit, productTerm:int32, recordField:hydra.core.Name, setElement:int32, sumTerm:unit, typeLambdaBody:unit, typeApplicationTerm:unit, injectionTerm:unit, wrappedTerm:unit}
  hydra.ast.Associativity = union{none:unit, left:unit, right:unit, both:unit}
  hydra.ast.BlockStyle = record{indent:maybe<string>, newlineBeforeContent:boolean, newlineAfterContent:boolean}
  hydra.ast.BracketExpr = record{brackets:hydra.ast.Brackets, enclosed:hydra.ast.Expr, style:hydra.ast.BlockStyle}
  hydra.ast.Brackets = record{open:hydra.ast.Symbol, close:hydra.ast.Symbol}
  hydra.ast.Expr = union{const:hydra.ast.Symbol, indent:hydra.ast.IndentedExpression, op:hydra.ast.OpExpr, brackets:hydra.ast.BracketExpr}
  hydra.ast.IndentStyle = union{allLines:string, subsequentLines:string}
  hydra.ast.IndentedExpression = record{style:hydra.ast.IndentStyle, expr:hydra.ast.Expr}
  hydra.ast.Op = record{symbol:hydra.ast.Symbol, padding:hydra.ast.Padding, precedence:hydra.ast.Precedence, associativity:hydra.ast.Associativity}
  hydra.ast.OpExpr = record{op:hydra.ast.Op, lhs:hydra.ast.Expr, rhs:hydra.ast.Expr}
  hydra.ast.Padding = record{left:hydra.ast.Ws, right:hydra.ast.Ws}
  hydra.ast.Precedence = wrap[hydra.ast.Precedence](int32)
  hydra.ast.Symbol = wrap[hydra.ast.Symbol](string)
  hydra.ast.Ws = union{none:unit, space:unit, break:unit, breakAndIndent:string, doubleBreak:unit}
  hydra.coders.AdapterContext = record{graph:hydra.graph.Graph, language:hydra.coders.Language, adapters:map<hydra.core.Name, (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term)>}
  hydra.coders.CoderDirection = union{encode:unit, decode:unit}
  hydra.coders.Language = record{name:hydra.coders.LanguageName, constraints:hydra.coders.LanguageConstraints}
  hydra.coders.LanguageConstraints = record{eliminationVariants:set<hydra.meta.EliminationVariant>, literalVariants:set<hydra.meta.LiteralVariant>, floatTypes:set<hydra.core.FloatType>, functionVariants:set<hydra.meta.FunctionVariant>, integerTypes:set<hydra.core.IntegerType>, termVariants:set<hydra.meta.TermVariant>, typeVariants:set<hydra.meta.TypeVariant>, types:(hydra.core.Type → boolean)}
  hydra.coders.LanguageName = wrap[hydra.coders.LanguageName](string)
  hydra.coders.SymmetricAdapter = (∀s.(∀t.(∀v.(hydra.compute.Adapter @ s @ s @ t @ t @ v @ v))))
  hydra.coders.TraversalOrder = union{pre:unit, post:unit}
  hydra.coders.TypeAdapter = (hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.coders.SymmetricAdapter @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Term)))
  hydra.compute.Adapter = (∀s1.(∀s2.(∀t1.(∀t2.(∀v1.(∀v2.record{isLossy:boolean, source:t1, target:t2, coder:(hydra.compute.Coder @ s1 @ s2 @ v1 @ v2)}))))))
  hydra.compute.Bicoder = (∀s1.(∀s2.(∀t1.(∀t2.(∀v1.(∀v2.record{encode:(t1 → (hydra.compute.Adapter @ s1 @ s2 @ t1 @ t2 @ v1 @ v2)), decode:(t2 → (hydra.compute.Adapter @ s2 @ s1 @ t2 @ t1 @ v2 @ v1))}))))))
  hydra.compute.Coder = (∀s1.(∀s2.(∀v1.(∀v2.record{encode:(v1 → (hydra.compute.Flow @ s1 @ v2)), decode:(v2 → (hydra.compute.Flow @ s2 @ v1))}))))
  hydra.compute.Flow = (∀s.(∀v.wrap[hydra.compute.Flow]((s → hydra.compute.Trace → (hydra.compute.FlowState @ s @ v)))))
  hydra.compute.FlowState = (∀s.(∀v.record{value:maybe<v>, state:s, trace:hydra.compute.Trace}))
  hydra.compute.Trace = record{stack:list<string>, messages:list<string>, other:map<hydra.core.Name, hydra.core.Term>}
  hydra.constraints.PathEquation = record{left:hydra.query.Path, right:hydra.query.Path}
  hydra.constraints.PatternImplication = record{antecedent:hydra.query.Pattern, consequent:hydra.query.Pattern}
  hydra.core.AnnotatedTerm = record{body:hydra.core.Term, annotation:map<hydra.core.Name, hydra.core.Term>}
  hydra.core.AnnotatedType = record{body:hydra.core.Type, annotation:map<hydra.core.Name, hydra.core.Term>}
  hydra.core.Application = record{function:hydra.core.Term, argument:hydra.core.Term}
  hydra.core.ApplicationType = record{function:hydra.core.Type, argument:hydra.core.Type}
  hydra.core.Binding = record{name:hydra.core.Name, term:hydra.core.Term, type:maybe<hydra.core.TypeScheme>}
  hydra.core.CaseStatement = record{typeName:hydra.core.Name, default:maybe<hydra.core.Term>, cases:list<hydra.core.Field>}
  hydra.core.EitherType = record{left:hydra.core.Type, right:hydra.core.Type}
  hydra.core.Elimination = union{product:hydra.core.TupleProjection, record:hydra.core.Projection, union:hydra.core.CaseStatement, wrap:hydra.core.Name}
  hydra.core.Field = record{name:hydra.core.Name, term:hydra.core.Term}
  hydra.core.FieldType = record{name:hydra.core.Name, type:hydra.core.Type}
  hydra.core.FloatType = union{bigfloat:unit, float32:unit, float64:unit}
  hydra.core.FloatValue = union{bigfloat:bigfloat, float32:float32, float64:float64}
  hydra.core.ForallType = record{parameter:hydra.core.Name, body:hydra.core.Type}
  hydra.core.Function = union{elimination:hydra.core.Elimination, lambda:hydra.core.Lambda, primitive:hydra.core.Name}
  hydra.core.FunctionType = record{domain:hydra.core.Type, codomain:hydra.core.Type}
  hydra.core.Injection = record{typeName:hydra.core.Name, field:hydra.core.Field}
  hydra.core.IntegerType = union{bigint:unit, int8:unit, int16:unit, int32:unit, int64:unit, uint8:unit, uint16:unit, uint32:unit, uint64:unit}
  hydra.core.IntegerValue = union{bigint:bigint, int8:int8, int16:int16, int32:int32, int64:int64, uint8:uint8, uint16:uint16, uint32:uint32, uint64:uint64}
  hydra.core.Lambda = record{parameter:hydra.core.Name, domain:maybe<hydra.core.Type>, body:hydra.core.Term}
  hydra.core.Let = record{bindings:list<hydra.core.Binding>, body:hydra.core.Term}
  hydra.core.Literal = union{binary:binary, boolean:boolean, float:hydra.core.FloatValue, integer:hydra.core.IntegerValue, string:string}
  hydra.core.LiteralType = union{binary:unit, boolean:unit, float:hydra.core.FloatType, integer:hydra.core.IntegerType, string:unit}
  hydra.core.MapType = record{keys:hydra.core.Type, values:hydra.core.Type}
  hydra.core.Name = wrap[hydra.core.Name](string)
  hydra.core.PairType = record{first:hydra.core.Type, second:hydra.core.Type}
  hydra.core.Projection = record{typeName:hydra.core.Name, field:hydra.core.Name}
  hydra.core.Record = record{typeName:hydra.core.Name, fields:list<hydra.core.Field>}
  hydra.core.RowType = record{typeName:hydra.core.Name, fields:list<hydra.core.FieldType>}
  hydra.core.Sum = record{index:int32, size:int32, term:hydra.core.Term}
  hydra.core.Term = union{annotated:hydra.core.AnnotatedTerm, application:hydra.core.Application, either:either<hydra.core.Term, hydra.core.Term>, function:hydra.core.Function, let:hydra.core.Let, list:list<hydra.core.Term>, literal:hydra.core.Literal, map:map<hydra.core.Term, hydra.core.Term>, maybe:maybe<hydra.core.Term>, pair:hydra.core.Term×hydra.core.Term, product:list<hydra.core.Term>, record:hydra.core.Record, set:set<hydra.core.Term>, sum:hydra.core.Sum, typeApplication:hydra.core.TypeApplicationTerm, typeLambda:hydra.core.TypeLambda, union:hydra.core.Injection, unit:unit, variable:hydra.core.Name, wrap:hydra.core.WrappedTerm}
  hydra.core.TupleProjection = record{arity:int32, index:int32, domain:maybe<list<hydra.core.Type>>}
  hydra.core.Type = union{annotated:hydra.core.AnnotatedType, application:hydra.core.ApplicationType, either:hydra.core.EitherType, forall:hydra.core.ForallType, function:hydra.core.FunctionType, list:hydra.core.Type, literal:hydra.core.LiteralType, map:hydra.core.MapType, maybe:hydra.core.Type, pair:hydra.core.PairType, product:list<hydra.core.Type>, record:hydra.core.RowType, set:hydra.core.Type, sum:list<hydra.core.Type>, union:hydra.core.RowType, unit:unit, variable:hydra.core.Name, wrap:hydra.core.WrappedType}
  hydra.core.TypeApplicationTerm = record{body:hydra.core.Term, type:hydra.core.Type}
  hydra.core.TypeLambda = record{parameter:hydra.core.Name, body:hydra.core.Term}
  hydra.core.TypeScheme = record{variables:list<hydra.core.Name>, type:hydra.core.Type}
  hydra.core.WrappedTerm = record{typeName:hydra.core.Name, body:hydra.core.Term}
  hydra.core.WrappedType = record{typeName:hydra.core.Name, body:hydra.core.Type}
  hydra.grammar.Constant = wrap[hydra.grammar.Constant](string)
  hydra.grammar.Grammar = wrap[hydra.grammar.Grammar](list<hydra.grammar.Production>)
  hydra.grammar.Label = wrap[hydra.grammar.Label](string)
  hydra.grammar.LabeledPattern = record{label:hydra.grammar.Label, pattern:hydra.grammar.Pattern}
  hydra.grammar.Pattern = union{alternatives:list<hydra.grammar.Pattern>, constant:hydra.grammar.Constant, ignored:hydra.grammar.Pattern, labeled:hydra.grammar.LabeledPattern, nil:unit, nonterminal:hydra.grammar.Symbol, option:hydra.grammar.Pattern, plus:hydra.grammar.Pattern, regex:hydra.grammar.Regex, sequence:list<hydra.grammar.Pattern>, star:hydra.grammar.Pattern}
  hydra.grammar.Production = record{symbol:hydra.grammar.Symbol, pattern:hydra.grammar.Pattern}
  hydra.grammar.Regex = wrap[hydra.grammar.Regex](string)
  hydra.grammar.Symbol = wrap[hydra.grammar.Symbol](string)
  hydra.graph.Graph = record{elements:map<hydra.core.Name, hydra.core.Binding>, environment:map<hydra.core.Name, maybe<hydra.core.Term>>, types:map<hydra.core.Name, hydra.core.TypeScheme>, body:hydra.core.Term, primitives:map<hydra.core.Name, hydra.graph.Primitive>, schema:maybe<hydra.graph.Graph>}
  hydra.graph.Primitive = record{name:hydra.core.Name, type:hydra.core.TypeScheme, implementation:(list<hydra.core.Term> → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term))}
  hydra.graph.TermCoder = (∀a.record{type:hydra.core.Type, coder:(hydra.compute.Coder @ hydra.graph.Graph @ hydra.graph.Graph @ hydra.core.Term @ a)})
  hydra.json.Value = union{array:list<hydra.json.Value>, boolean:boolean, null:unit, number:bigfloat, object:map<string, hydra.json.Value>, string:string}
  hydra.meta.EliminationVariant = union{product:unit, record:unit, union:unit, wrap:unit}
  hydra.meta.FunctionVariant = union{elimination:unit, lambda:unit, primitive:unit}
  hydra.meta.LiteralVariant = union{binary:unit, boolean:unit, float:unit, integer:unit, string:unit}
  hydra.meta.TermVariant = union{annotated:unit, application:unit, either:unit, function:unit, let:unit, list:unit, literal:unit, map:unit, maybe:unit, pair:unit, product:unit, record:unit, set:unit, sum:unit, typeApplication:unit, typeLambda:unit, union:unit, unit:unit, variable:unit, wrap:unit}
  hydra.meta.TypeClass = union{equality:unit, ordering:unit}
  hydra.meta.TypeVariant = union{annotated:unit, application:unit, either:unit, forall:unit, function:unit, list:unit, literal:unit, map:unit, maybe:unit, pair:unit, product:unit, record:unit, set:unit, sum:unit, union:unit, unit:unit, variable:unit, wrap:unit}
  hydra.module.Definition = union{term:hydra.module.TermDefinition, type:hydra.module.TypeDefinition}
  hydra.module.FileExtension = wrap[hydra.module.FileExtension](string)
  hydra.module.Library = record{namespace:hydra.module.Namespace, prefix:string, primitives:list<hydra.graph.Primitive>}
  hydra.module.Module = record{namespace:hydra.module.Namespace, elements:list<hydra.core.Binding>, termDependencies:list<hydra.module.Module>, typeDependencies:list<hydra.module.Module>, description:maybe<string>}
  hydra.module.Namespace = wrap[hydra.module.Namespace](string)
  hydra.module.Namespaces = (∀n.record{focus:hydra.module.Namespace×n, mapping:map<hydra.module.Namespace, n>})
  hydra.module.QualifiedName = record{namespace:maybe<hydra.module.Namespace>, local:string}
  hydra.module.TermDefinition = record{name:hydra.core.Name, term:hydra.core.Term, type:hydra.core.Type}
  hydra.module.TypeDefinition = record{name:hydra.core.Name, type:hydra.core.Type}
  hydra.phantoms.TBinding = (∀a.record{name:hydra.core.Name, term:(hydra.phantoms.TTerm @ a)})
  hydra.phantoms.TTerm = (∀a.wrap[hydra.phantoms.TTerm](hydra.core.Term))
  hydra.query.ComparisonConstraint = union{equal:unit, notEqual:unit, lessThan:unit, greaterThan:unit, lessThanOrEqual:unit, greaterThanOrEqual:unit}
  hydra.query.Edge = record{type:hydra.core.Name, out:maybe<hydra.core.Name>, in:maybe<hydra.core.Name>}
  hydra.query.GraphPattern = record{graph:hydra.core.Name, patterns:list<hydra.query.Pattern>}
  hydra.query.Node = union{term:hydra.core.Term, variable:hydra.query.Variable, wildcard:unit}
  hydra.query.Path = union{step:hydra.query.Step, regex:hydra.query.RegexSequence, inverse:hydra.query.Path}
  hydra.query.Pattern = union{triple:hydra.query.TriplePattern, negation:hydra.query.Pattern, conjunction:list<hydra.query.Pattern>, disjunction:list<hydra.query.Pattern>, graph:hydra.query.GraphPattern}
  hydra.query.Query = record{variables:list<hydra.query.Variable>, patterns:list<hydra.query.Pattern>}
  hydra.query.Range = record{min:int32, max:int32}
  hydra.query.RegexQuantifier = union{one:unit, zeroOrOne:unit, zeroOrMore:unit, oneOrMore:unit, exactly:int32, atLeast:int32, range:hydra.query.Range}
  hydra.query.RegexSequence = record{path:hydra.query.Path, quantifier:hydra.query.RegexQuantifier}
  hydra.query.Step = union{edge:hydra.query.Edge, project:hydra.core.Projection, compare:hydra.query.ComparisonConstraint}
  hydra.query.TriplePattern = record{subject:hydra.query.Node, predicate:hydra.query.Path, object:hydra.query.Node}
  hydra.query.Variable = wrap[hydra.query.Variable](string)
  hydra.relational.ColumnName = wrap[hydra.relational.ColumnName](string)
  hydra.relational.ColumnSchema = (∀t.record{name:hydra.relational.ColumnName, domain:t})
  hydra.relational.ForeignKey = record{foreignRelation:hydra.relational.RelationName, keys:map<hydra.relational.ColumnName, hydra.relational.ColumnName>}
  hydra.relational.PrimaryKey = wrap[hydra.relational.PrimaryKey](list<hydra.relational.ColumnName>)
  hydra.relational.Relation = (∀v.wrap[hydra.relational.Relation](list<(hydra.relational.Row @ v)>))
  hydra.relational.RelationName = wrap[hydra.relational.RelationName](string)
  hydra.relational.RelationSchema = (∀t.record{name:hydra.relational.RelationName, columns:list<(hydra.relational.ColumnSchema @ t)>, primaryKeys:list<hydra.relational.PrimaryKey>, foreignKeys:list<hydra.relational.ForeignKey>})
  hydra.relational.Relationship = (∀v.wrap[hydra.relational.Relationship](set<map<hydra.relational.ColumnName, v>>))
  hydra.relational.Row = (∀v.wrap[hydra.relational.Row](list<v>))
  hydra.tabular.DataRow = (∀v.wrap[hydra.tabular.DataRow](list<maybe<v>>))
  hydra.tabular.HeaderRow = wrap[hydra.tabular.HeaderRow](list<string>)
  hydra.tabular.Table = (∀v.record{header:maybe<hydra.tabular.HeaderRow>, data:list<(hydra.tabular.DataRow @ v)>})
  hydra.testing.CaseConversionTestCase = record{fromConvention:hydra.util.CaseConvention, toConvention:hydra.util.CaseConvention, fromString:string, toString:string}
  hydra.testing.EvaluationStyle = union{eager:unit, lazy:unit}
  hydra.testing.EvaluationTestCase = record{evaluationStyle:hydra.testing.EvaluationStyle, input:hydra.core.Term, output:hydra.core.Term}
  hydra.testing.InferenceFailureTestCase = record{input:hydra.core.Term}
  hydra.testing.InferenceTestCase = record{input:hydra.core.Term, output:hydra.core.TypeScheme}
  hydra.testing.Tag = wrap[hydra.testing.Tag](string)
  hydra.testing.TestCase = union{caseConversion:hydra.testing.CaseConversionTestCase, evaluation:hydra.testing.EvaluationTestCase, inference:hydra.testing.InferenceTestCase, inferenceFailure:hydra.testing.InferenceFailureTestCase}
  hydra.testing.TestCaseWithMetadata = record{name:string, case:hydra.testing.TestCase, description:maybe<string>, tags:list<hydra.testing.Tag>}
  hydra.testing.TestGroup = record{name:string, description:maybe<string>, subgroups:list<hydra.testing.TestGroup>, cases:list<hydra.testing.TestCaseWithMetadata>}
  hydra.topology.Graph = map<hydra.topology.Vertex, list<hydra.topology.Vertex>>
  hydra.topology.OrderingIsomorphism = (∀a.record{encode:(list<a> → list<a>), decode:(list<a> → list<a>)})
  hydra.topology.TarjanState = record{counter:int32, indices:map<hydra.topology.Vertex, int32>, lowLinks:map<hydra.topology.Vertex, int32>, stack:list<hydra.topology.Vertex>, onStack:set<hydra.topology.Vertex>, sccs:list<list<hydra.topology.Vertex>>}
  hydra.topology.Vertex = int32
  hydra.typing.InferenceContext = record{schemaTypes:map<hydra.core.Name, hydra.core.TypeScheme>, primitiveTypes:map<hydra.core.Name, hydra.core.TypeScheme>, dataTypes:map<hydra.core.Name, hydra.core.TypeScheme>, debug:boolean}
  hydra.typing.InferenceResult = record{term:hydra.core.Term, type:hydra.core.Type, subst:hydra.typing.TypeSubst}
  hydra.typing.TermSubst = wrap[hydra.typing.TermSubst](map<hydra.core.Name, hydra.core.Term>)
  hydra.typing.TypeConstraint = record{left:hydra.core.Type, right:hydra.core.Type, comment:string}
  hydra.typing.TypeContext = record{types:map<hydra.core.Name, hydra.core.Type>, variables:set<hydra.core.Name>, inferenceContext:hydra.typing.InferenceContext}
  hydra.typing.TypeSubst = wrap[hydra.typing.TypeSubst](map<hydra.core.Name, hydra.core.Type>)
  hydra.util.CaseConvention = union{camel:unit, pascal:unit, lowerSnake:unit, upperSnake:unit}
  hydra.util.Comparison = union{lessThan:unit, equalTo:unit, greaterThan:unit}
  hydra.util.Precision = union{arbitrary:unit, bits:int32}
  hydra.workflow.HydraSchemaSpec = record{modules:list<hydra.module.Module>, typeName:hydra.core.Name}
  hydra.workflow.LastMile = (∀s.(∀a.record{encoder:(hydra.core.Type → (hydra.compute.Flow @ s @ (hydra.core.Term → hydra.graph.Graph → (hydra.compute.Flow @ s @ list<a>)))), serializer:(list<a> → (hydra.compute.Flow @ s @ string)), fileExtension:string}))
  hydra.workflow.SchemaSpec = union{hydra:hydra.workflow.HydraSchemaSpec, file:string, provided:unit}
  hydra.workflow.TransformWorkflow = record{name:string, schemaSpec:hydra.workflow.SchemaSpec, srcDir:string, destDir:string}

Terms:
  hydra.adapt.literals.comparePrecision : ((hydra.util.Precision → hydra.util.Precision → hydra.util.Comparison))
  hydra.adapt.literals.convertFloatValue : ((hydra.core.FloatType → hydra.core.FloatValue → hydra.core.FloatValue))
  hydra.adapt.literals.convertIntegerValue : ((hydra.core.IntegerType → hydra.core.IntegerValue → hydra.core.IntegerValue))
  hydra.adapt.literals.disclaimer : ((boolean → string → string → string))
  hydra.adapt.literals.floatAdapter : (∀[t0,t1].(hydra.core.FloatType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ t0 @ t1 @ hydra.core.FloatType @ hydra.core.FloatType @ hydra.core.FloatValue @ hydra.core.FloatValue))))
  hydra.adapt.literals.integerAdapter : (∀[t0,t1].(hydra.core.IntegerType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ t0 @ t1 @ hydra.core.IntegerType @ hydra.core.IntegerType @ hydra.core.IntegerValue @ hydra.core.IntegerValue))))
  hydra.adapt.literals.literalAdapter : (∀[t0].(hydra.core.LiteralType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ t0 @ t0 @ hydra.core.LiteralType @ hydra.core.LiteralType @ hydra.core.Literal @ hydra.core.Literal))))
  hydra.adapt.modules.adaptTypeToLanguage : (∀[t0,t1].(hydra.coders.Language → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.adapt.modules.adaptTypeToLanguageAndEncode : (∀[t0].(hydra.coders.Language → (hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.adapt.modules.adaptedModuleDefinitions : (∀[t0].(hydra.coders.Language → hydra.module.Module → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.module.Definition>)))
  hydra.adapt.modules.constructCoder : (∀[t0,t1,t2].(hydra.coders.Language → (hydra.core.Term → (hydra.compute.Flow @ t0 @ t1)) → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ (hydra.compute.Coder @ t0 @ t2 @ hydra.core.Term @ t1))))
  hydra.adapt.modules.languageAdapter : (∀[t0,t1].(hydra.coders.Language → hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ (hydra.compute.Adapter @ t0 @ t1 @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.modules.transformModule : (∀[t0,t1,t2,t3].(hydra.coders.Language → (hydra.core.Term → (hydra.compute.Flow @ t0 @ t1)) → (hydra.module.Module → map<hydra.core.Type, (hydra.compute.Coder @ t0 @ t2 @ hydra.core.Term @ t1)> → list<hydra.core.Binding×hydra.core.TypeApplicationTerm> → (hydra.compute.Flow @ hydra.graph.Graph @ t3)) → hydra.module.Module → (hydra.compute.Flow @ hydra.graph.Graph @ t3)))
  hydra.adapt.simple.adaptDataGraph : ((hydra.coders.LanguageConstraints → boolean → hydra.graph.Graph → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.graph.Graph)))
  hydra.adapt.simple.adaptFloatType : ((hydra.coders.LanguageConstraints → hydra.core.FloatType → maybe<hydra.core.FloatType>))
  hydra.adapt.simple.adaptGraphSchema : (∀[t0,t1].(hydra.coders.LanguageConstraints → map<hydra.core.LiteralType, hydra.core.LiteralType> → map<t0, hydra.core.Type> → (hydra.compute.Flow @ t1 @ map<t0, hydra.core.Type>)))
  hydra.adapt.simple.adaptIntegerType : ((hydra.coders.LanguageConstraints → hydra.core.IntegerType → maybe<hydra.core.IntegerType>))
  hydra.adapt.simple.adaptLiteral : ((hydra.core.LiteralType → hydra.core.Literal → hydra.core.Literal))
  hydra.adapt.simple.adaptLiteralType : ((hydra.coders.LanguageConstraints → hydra.core.LiteralType → maybe<hydra.core.LiteralType>))
  hydra.adapt.simple.adaptLiteralTypesMap : ((hydra.coders.LanguageConstraints → map<hydra.core.LiteralType, hydra.core.LiteralType>))
  hydra.adapt.simple.adaptLiteralValue : (∀[t0].(map<t0, hydra.core.LiteralType> → t0 → hydra.core.Literal → hydra.core.Literal))
  hydra.adapt.simple.adaptPrimitive : (∀[t0].(hydra.coders.LanguageConstraints → map<hydra.core.LiteralType, hydra.core.LiteralType> → hydra.graph.Primitive → (hydra.compute.Flow @ t0 @ hydra.graph.Primitive)))
  hydra.adapt.simple.adaptTerm : ((hydra.coders.LanguageConstraints → map<hydra.core.LiteralType, hydra.core.LiteralType> → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.adapt.simple.adaptType : (∀[t0].(hydra.coders.LanguageConstraints → map<hydra.core.LiteralType, hydra.core.LiteralType> → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.adapt.simple.adaptTypeScheme : (∀[t0].(hydra.coders.LanguageConstraints → map<hydra.core.LiteralType, hydra.core.LiteralType> → hydra.core.TypeScheme → (hydra.compute.Flow @ t0 @ hydra.core.TypeScheme)))
  hydra.adapt.simple.dataGraphToDefinitions : ((hydra.coders.LanguageConstraints → boolean → hydra.graph.Graph → list<list<hydra.core.Name>> → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.graph.Graph×list<list<hydra.module.TermDefinition>>)))
  hydra.adapt.simple.literalTypeSupported : ((hydra.coders.LanguageConstraints → hydra.core.LiteralType → boolean))
  hydra.adapt.simple.schemaGraphToDefinitions : ((hydra.coders.LanguageConstraints → hydra.graph.Graph → list<list<hydra.core.Name>> → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>×list<list<hydra.module.TypeDefinition>>)))
  hydra.adapt.simple.termAlternatives : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.Term>)))
  hydra.adapt.simple.typeAlternatives : ((hydra.core.Type → list<hydra.core.Type>))
  hydra.adapt.terms.fieldAdapter : ((hydra.core.FieldType → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.FieldType @ hydra.core.FieldType @ hydra.core.Field @ hydra.core.Field))))
  hydra.adapt.terms.forTypeReference : ((hydra.core.Name → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.functionProxyName : (hydra.core.Name)
  hydra.adapt.terms.functionProxyType : (∀[t0].(t0 → hydra.core.Type))
  hydra.adapt.terms.functionToUnion : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.lambdaToMonotype : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.maybeToList : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passApplication : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passEither : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passForall : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passFunction : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passList : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passLiteral : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passMap : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passOptional : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passProduct : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passRecord : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passSet : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passSum : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passUnion : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passUnit : (∀[t0,t1,t2,t3].(t0 → (hydra.compute.Flow @ t1 @ (hydra.compute.Adapter @ t2 @ t3 @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.passWrapped : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.setToList : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.simplifyApplication : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.termAdapter : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.unionToRecord : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.unionTypeToRecordType : ((hydra.core.RowType → hydra.core.RowType))
  hydra.adapt.terms.unitToRecord : (∀[t0,t1,t2,t3].(t0 → (hydra.compute.Flow @ t1 @ (hydra.compute.Adapter @ t2 @ t3 @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.terms.withGraphContext : (∀[t0].((hydra.compute.Flow @ hydra.graph.Graph @ t0) → (hydra.compute.Flow @ hydra.coders.AdapterContext @ t0)))
  hydra.adapt.terms.wrapToUnwrapped : ((hydra.core.Type → (hydra.compute.Flow @ hydra.coders.AdapterContext @ (hydra.compute.Adapter @ hydra.coders.AdapterContext @ hydra.coders.AdapterContext @ hydra.core.Type @ hydra.core.Type @ hydra.core.Term @ hydra.core.Term))))
  hydra.adapt.utils.bidirectional : (∀[t0,t1].((hydra.coders.CoderDirection → t0 → (hydra.compute.Flow @ t1 @ t0)) → (hydra.compute.Coder @ t1 @ t1 @ t0 @ t0)))
  hydra.adapt.utils.chooseAdapter : (∀[t0,t1,t2,t3,t4].((t0 → (hydra.compute.Flow @ t1 @ list<(hydra.compute.Adapter @ t2 @ t3 @ t0 @ t0 @ t4 @ t4)>)) → (t0 → boolean) → (t0 → string) → (t0 → string) → t0 → (hydra.compute.Flow @ t1 @ (hydra.compute.Adapter @ t2 @ t3 @ t0 @ t0 @ t4 @ t4))))
  hydra.adapt.utils.composeCoders : (∀[t0,t1,t2,t3,t4].((hydra.compute.Coder @ t0 @ t1 @ t2 @ t3) → (hydra.compute.Coder @ t0 @ t1 @ t3 @ t4) → (hydra.compute.Coder @ t0 @ t1 @ t2 @ t4)))
  hydra.adapt.utils.encodeDecode : (∀[t0,t1].(hydra.coders.CoderDirection → (hydra.compute.Coder @ t0 @ t0 @ t1 @ t1) → t1 → (hydra.compute.Flow @ t0 @ t1)))
  hydra.adapt.utils.floatTypeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.FloatType → boolean))
  hydra.adapt.utils.idAdapter : (∀[t0,t1,t2,t3].(t0 → (hydra.compute.Adapter @ t1 @ t2 @ t0 @ t0 @ t3 @ t3)))
  hydra.adapt.utils.idCoder : (∀[t0,t1,t2].(hydra.compute.Coder @ t0 @ t1 @ t2 @ t2))
  hydra.adapt.utils.integerTypeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.IntegerType → boolean))
  hydra.adapt.utils.literalTypeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.LiteralType → boolean))
  hydra.adapt.utils.nameToFilePath : ((hydra.util.CaseConvention → hydra.util.CaseConvention → hydra.module.FileExtension → hydra.core.Name → string))
  hydra.adapt.utils.typeIsSupported : ((hydra.coders.LanguageConstraints → hydra.core.Type → boolean))
  hydra.adapt.utils.unidirectionalCoder : (∀[t0,t1,t2,t3].((t0 → (hydra.compute.Flow @ t1 @ t2)) → (hydra.compute.Coder @ t1 @ t3 @ t0 @ t2)))
  hydra.annotations.aggregateAnnotations : (∀[t0,t1,t2,t3].((t0 → maybe<t1>) → (t1 → t0) → (t1 → map<t2, t3>) → t0 → map<t2, t3>))
  hydra.annotations.debugIf : (∀[t0,t1].(t0 → string → (hydra.compute.Flow @ t1 @ unit)))
  hydra.annotations.failOnFlag : (∀[t0].(hydra.core.Name → string → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.getAttr : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ maybe<hydra.core.Term>)))
  hydra.annotations.getAttrWithDefault : (∀[t0].(hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.annotations.getCount : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ int32)))
  hydra.annotations.getDebugId : (∀[t0].(hydra.compute.Flow @ t0 @ maybe<string>))
  hydra.annotations.getDescription : ((map<hydra.core.Name, hydra.core.Term> → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<string>)))
  hydra.annotations.getTermAnnotation : ((hydra.core.Name → hydra.core.Term → maybe<hydra.core.Term>))
  hydra.annotations.getTermDescription : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<string>)))
  hydra.annotations.getType : ((map<hydra.core.Name, hydra.core.Term> → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<hydra.core.Type>)))
  hydra.annotations.getTypeAnnotation : ((hydra.core.Name → hydra.core.Type → maybe<hydra.core.Term>))
  hydra.annotations.getTypeClasses : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, set<hydra.meta.TypeClass>>)))
  hydra.annotations.getTypeDescription : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<string>)))
  hydra.annotations.hasDescription : (∀[t0].(map<hydra.core.Name, t0> → boolean))
  hydra.annotations.hasFlag : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ boolean)))
  hydra.annotations.hasTypeDescription : ((hydra.core.Type → boolean))
  hydra.annotations.isNativeType : ((hydra.core.Binding → boolean))
  hydra.annotations.nextCount : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ int32)))
  hydra.annotations.normalizeTermAnnotations : ((hydra.core.Term → hydra.core.Term))
  hydra.annotations.normalizeTypeAnnotations : ((hydra.core.Type → hydra.core.Type))
  hydra.annotations.putAttr : (∀[t0].(hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.putCount : (∀[t0].(hydra.core.Name → int32 → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.resetCount : (∀[t0].(hydra.core.Name → (hydra.compute.Flow @ t0 @ unit)))
  hydra.annotations.setAnnotation : (∀[t0,t1].(t0 → maybe<t1> → map<t0, t1> → map<t0, t1>))
  hydra.annotations.setDescription : ((maybe<string> → map<hydra.core.Name, hydra.core.Term> → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.setTermAnnotation : ((hydra.core.Name → maybe<hydra.core.Term> → hydra.core.Term → hydra.core.Term))
  hydra.annotations.setTermDescription : ((maybe<string> → hydra.core.Term → hydra.core.Term))
  hydra.annotations.setType : ((maybe<hydra.core.Type> → map<hydra.core.Name, hydra.core.Term> → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.setTypeAnnotation : ((hydra.core.Name → maybe<hydra.core.Term> → hydra.core.Type → hydra.core.Type))
  hydra.annotations.setTypeClasses : ((map<hydra.core.Name, set<hydra.meta.TypeClass>> → hydra.core.Term → hydra.core.Term))
  hydra.annotations.setTypeDescription : ((maybe<string> → hydra.core.Type → hydra.core.Type))
  hydra.annotations.termAnnotationInternal : ((hydra.core.Term → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.typeAnnotationInternal : ((hydra.core.Type → map<hydra.core.Name, hydra.core.Term>))
  hydra.annotations.typeElement : ((hydra.core.Name → hydra.core.Type → hydra.core.Binding))
  hydra.annotations.whenFlag : (∀[t0,t1].(hydra.core.Name → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.annotations.withDepth : (∀[t0,t1].(hydra.core.Name → (int32 → (hydra.compute.Flow @ t0 @ t1)) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.arity.functionArity : ((hydra.core.Function → int32))
  hydra.arity.primitiveArity : ((hydra.graph.Primitive → int32))
  hydra.arity.termArity : ((hydra.core.Term → int32))
  hydra.arity.typeArity : ((hydra.core.Type → int32))
  hydra.arity.typeSchemeArity : ((hydra.core.TypeScheme → int32))
  hydra.arity.uncurryType : ((hydra.core.Type → list<hydra.core.Type>))
  hydra.checking.allEqual : (∀[t0].(list<t0> → boolean))
  hydra.checking.applyTypeArgumentsToType : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.checkForUnboundTypeVariables : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term → (hydra.compute.Flow @ t0 @ unit)))
  hydra.checking.checkNominalApplication : (∀[t0].(hydra.typing.TypeContext → hydra.core.Name → list<hydra.core.Type> → (hydra.compute.Flow @ t0 @ unit)))
  hydra.checking.checkSameType : (∀[t0].(hydra.typing.TypeContext → string → list<hydra.core.Type> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.checkType : (∀[t0].(hydra.typing.TypeContext → hydra.core.Term → hydra.core.Type → (hydra.compute.Flow @ t0 @ unit)))
  hydra.checking.checkTypeSubst : (∀[t0].(hydra.typing.InferenceContext → hydra.typing.TypeSubst → (hydra.compute.Flow @ t0 @ hydra.typing.TypeSubst)))
  hydra.checking.checkTypeVariables : (∀[t0].(hydra.typing.TypeContext → hydra.core.Type → (hydra.compute.Flow @ t0 @ unit)))
  hydra.checking.toFContext : ((hydra.typing.InferenceContext → map<hydra.core.Name, hydra.core.Type>))
  hydra.checking.typeListsEffectivelyEqual : ((hydra.typing.TypeContext → list<hydra.core.Type> → list<hydra.core.Type> → boolean))
  hydra.checking.typeOf : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfAnnotatedTerm : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.AnnotatedTerm → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfApplication : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Application → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfCaseStatement : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.CaseStatement → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfEither : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → either<hydra.core.Term, hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfInjection : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Injection → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfLambda : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Lambda → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfLet : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Let → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfList : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfLiteral : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Literal → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfMap : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → map<hydra.core.Term, hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfMaybe : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → maybe<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfPair : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Term×hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfPrimitive : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfProjection : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Projection → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfRecord : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Record → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfSet : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → set<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfTuple : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfTupleProjection : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.TupleProjection → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfTypeApplication : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.TypeApplicationTerm → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfTypeLambda : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.TypeLambda → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfUnit : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfUnwrap : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfVariable : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typeOfWrappedTerm : (∀[t0].(hydra.typing.TypeContext → list<hydra.core.Type> → hydra.core.WrappedTerm → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.checking.typesAllEffectivelyEqual : ((hydra.typing.TypeContext → list<hydra.core.Type> → boolean))
  hydra.checking.typesEffectivelyEqual : ((hydra.typing.TypeContext → hydra.core.Type → hydra.core.Type → boolean))
  hydra.constants.debugInference : (boolean)
  hydra.constants.ignoredVariable : (string)
  hydra.constants.key_classes : (hydra.core.Name)
  hydra.constants.key_debugId : (hydra.core.Name)
  hydra.constants.key_deprecated : (hydra.core.Name)
  hydra.constants.key_description : (hydra.core.Name)
  hydra.constants.key_exclude : (hydra.core.Name)
  hydra.constants.key_firstClassType : (hydra.core.Name)
  hydra.constants.key_freshTypeVariableCount : (hydra.core.Name)
  hydra.constants.key_maxLength : (hydra.core.Name)
  hydra.constants.key_minLength : (hydra.core.Name)
  hydra.constants.key_preserveFieldName : (hydra.core.Name)
  hydra.constants.key_type : (hydra.core.Name)
  hydra.constants.maxInt32 : (int32)
  hydra.constants.maxTraceDepth : (int32)
  hydra.constants.placeholderName : (hydra.core.Name)
  hydra.constants.warningAutoGeneratedFile : (string)
  hydra.decode.core.applicationType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.ApplicationType)))
  hydra.decode.core.eitherType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.EitherType)))
  hydra.decode.core.fieldType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FieldType)))
  hydra.decode.core.fieldTypes : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.FieldType>)))
  hydra.decode.core.floatType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FloatType)))
  hydra.decode.core.forallType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.ForallType)))
  hydra.decode.core.functionType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FunctionType)))
  hydra.decode.core.integerType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.IntegerType)))
  hydra.decode.core.literalType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.LiteralType)))
  hydra.decode.core.mapType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.MapType)))
  hydra.decode.core.name : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Name)))
  hydra.decode.core.rowType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.RowType)))
  hydra.decode.core.string : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ string)))
  hydra.decode.core.type : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.decode.core.typeScheme : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.TypeScheme)))
  hydra.decode.core.wrappedType : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.WrappedType)))
  hydra.describe.core.floatType : ((hydra.core.FloatType → string))
  hydra.describe.core.integerType : ((hydra.core.IntegerType → string))
  hydra.describe.core.literalType : ((hydra.core.LiteralType → string))
  hydra.describe.core.type : ((hydra.core.Type → string))
  hydra.describe.util.precision : ((hydra.util.Precision → string))
  hydra.encode.core.annotatedTerm : ((hydra.core.AnnotatedTerm → hydra.core.Term))
  hydra.encode.core.annotatedType : ((hydra.core.AnnotatedType → hydra.core.Term))
  hydra.encode.core.application : ((hydra.core.Application → hydra.core.Term))
  hydra.encode.core.applicationType : ((hydra.core.ApplicationType → hydra.core.Term))
  hydra.encode.core.binding : ((hydra.core.Binding → hydra.core.Term))
  hydra.encode.core.caseStatement : ((hydra.core.CaseStatement → hydra.core.Term))
  hydra.encode.core.eitherType : ((hydra.core.EitherType → hydra.core.Term))
  hydra.encode.core.elimination : ((hydra.core.Elimination → hydra.core.Term))
  hydra.encode.core.field : ((hydra.core.Field → hydra.core.Term))
  hydra.encode.core.fieldType : ((hydra.core.FieldType → hydra.core.Term))
  hydra.encode.core.floatType : ((hydra.core.FloatType → hydra.core.Term))
  hydra.encode.core.floatValue : ((hydra.core.FloatValue → hydra.core.Term))
  hydra.encode.core.forallType : ((hydra.core.ForallType → hydra.core.Term))
  hydra.encode.core.function : ((hydra.core.Function → hydra.core.Term))
  hydra.encode.core.functionType : ((hydra.core.FunctionType → hydra.core.Term))
  hydra.encode.core.injection : ((hydra.core.Injection → hydra.core.Term))
  hydra.encode.core.integerType : ((hydra.core.IntegerType → hydra.core.Term))
  hydra.encode.core.integerValue : ((hydra.core.IntegerValue → hydra.core.Term))
  hydra.encode.core.isEncodedType : ((hydra.core.Term → boolean))
  hydra.encode.core.isType : ((hydra.core.Type → boolean))
  hydra.encode.core.isUnitTerm : ((hydra.core.Term → boolean))
  hydra.encode.core.isUnitType : ((hydra.core.Type → boolean))
  hydra.encode.core.lambda : ((hydra.core.Lambda → hydra.core.Term))
  hydra.encode.core.let : ((hydra.core.Let → hydra.core.Term))
  hydra.encode.core.literal : ((hydra.core.Literal → hydra.core.Term))
  hydra.encode.core.literalType : ((hydra.core.LiteralType → hydra.core.Term))
  hydra.encode.core.mapType : ((hydra.core.MapType → hydra.core.Term))
  hydra.encode.core.name : ((hydra.core.Name → hydra.core.Term))
  hydra.encode.core.pairType : ((hydra.core.PairType → hydra.core.Term))
  hydra.encode.core.projection : ((hydra.core.Projection → hydra.core.Term))
  hydra.encode.core.record : ((hydra.core.Record → hydra.core.Term))
  hydra.encode.core.rowType : ((hydra.core.RowType → hydra.core.Term))
  hydra.encode.core.sum : ((hydra.core.Sum → hydra.core.Term))
  hydra.encode.core.term : ((hydra.core.Term → hydra.core.Term))
  hydra.encode.core.tupleProjection : ((hydra.core.TupleProjection → hydra.core.Term))
  hydra.encode.core.type : ((hydra.core.Type → hydra.core.Term))
  hydra.encode.core.typeApplicationTerm : ((hydra.core.TypeApplicationTerm → hydra.core.Term))
  hydra.encode.core.typeLambda : ((hydra.core.TypeLambda → hydra.core.Term))
  hydra.encode.core.typeScheme : ((hydra.core.TypeScheme → hydra.core.Term))
  hydra.encode.core.wrappedTerm : ((hydra.core.WrappedTerm → hydra.core.Term))
  hydra.encode.core.wrappedType : ((hydra.core.WrappedType → hydra.core.Term))
  hydra.extract.core.bigfloat : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ bigfloat)))
  hydra.extract.core.bigfloatValue : (∀[t0].(hydra.core.FloatValue → (hydra.compute.Flow @ t0 @ bigfloat)))
  hydra.extract.core.bigint : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ bigint)))
  hydra.extract.core.bigintValue : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ bigint)))
  hydra.extract.core.binary : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ binary)))
  hydra.extract.core.binaryLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ binary)))
  hydra.extract.core.boolean : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ boolean)))
  hydra.extract.core.booleanLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ boolean)))
  hydra.extract.core.caseField : ((hydra.core.Name → string → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Field)))
  hydra.extract.core.cases : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.CaseStatement)))
  hydra.extract.core.eitherTerm : (∀[t0,t1].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t1)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ either<t0, t1>)))
  hydra.extract.core.eitherType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.EitherType)))
  hydra.extract.core.field : (∀[t0].(hydra.core.Name → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → list<hydra.core.Field> → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.extract.core.float32 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ float32)))
  hydra.extract.core.float32Value : (∀[t0].(hydra.core.FloatValue → (hydra.compute.Flow @ t0 @ float32)))
  hydra.extract.core.float64 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ float64)))
  hydra.extract.core.float64Value : (∀[t0].(hydra.core.FloatValue → (hydra.compute.Flow @ t0 @ float64)))
  hydra.extract.core.floatLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ hydra.core.FloatValue)))
  hydra.extract.core.floatValue : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.FloatValue)))
  hydra.extract.core.functionType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.FunctionType)))
  hydra.extract.core.injection : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Field)))
  hydra.extract.core.int16 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int16)))
  hydra.extract.core.int16Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int16)))
  hydra.extract.core.int32 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int32)))
  hydra.extract.core.int32Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int32)))
  hydra.extract.core.int64 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int64)))
  hydra.extract.core.int64Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int64)))
  hydra.extract.core.int8 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ int8)))
  hydra.extract.core.int8Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ int8)))
  hydra.extract.core.integerLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ hydra.core.IntegerValue)))
  hydra.extract.core.integerValue : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.IntegerValue)))
  hydra.extract.core.lambda : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Lambda)))
  hydra.extract.core.lambdaBody : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.letBinding : ((string → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.letTerm : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Let)))
  hydra.extract.core.list : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.Term>)))
  hydra.extract.core.listHead : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.listOf : (∀[t0].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<t0>)))
  hydra.extract.core.listType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.core.literal : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Literal)))
  hydra.extract.core.map : (∀[t0,t1].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t1)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ map<t0, t1>)))
  hydra.extract.core.mapType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.MapType)))
  hydra.extract.core.maybeTerm : (∀[t0].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<t0>)))
  hydra.extract.core.maybeType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.core.nArgs : (∀[t0,t1].(hydra.core.Name → int32 → list<t0> → (hydra.compute.Flow @ t1 @ unit)))
  hydra.extract.core.pair : (∀[t0,t1].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t1)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0×t1)))
  hydra.extract.core.productType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.Type>)))
  hydra.extract.core.record : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.Field>)))
  hydra.extract.core.recordType : (∀[t0].(hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.FieldType>)))
  hydra.extract.core.set : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ set<hydra.core.Term>)))
  hydra.extract.core.setOf : (∀[t0].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ set<t0>)))
  hydra.extract.core.setType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.core.string : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ string)))
  hydra.extract.core.stringLiteral : (∀[t0].(hydra.core.Literal → (hydra.compute.Flow @ t0 @ string)))
  hydra.extract.core.sumType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.Type>)))
  hydra.extract.core.termRecord : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Record)))
  hydra.extract.core.tuple2 : (∀[t0,t1].((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)) → (hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t1)) → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0×t1)))
  hydra.extract.core.uint16 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint16)))
  hydra.extract.core.uint16Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint16)))
  hydra.extract.core.uint32 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint32)))
  hydra.extract.core.uint32Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint32)))
  hydra.extract.core.uint64 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint64)))
  hydra.extract.core.uint64Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint64)))
  hydra.extract.core.uint8 : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ uint8)))
  hydra.extract.core.uint8Value : (∀[t0].(hydra.core.IntegerValue → (hydra.compute.Flow @ t0 @ uint8)))
  hydra.extract.core.unionType : (∀[t0].(hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ list<hydra.core.FieldType>)))
  hydra.extract.core.unit : (∀[t0].(hydra.core.Term → (hydra.compute.Flow @ t0 @ unit)))
  hydra.extract.core.unitVariant : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Name)))
  hydra.extract.core.variant : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Field)))
  hydra.extract.core.wrap : ((hydra.core.Name → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.extract.core.wrappedType : (∀[t0].(hydra.core.Name → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.extract.util.comparison : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.util.Comparison)))
  hydra.formatting.capitalize : ((string → string))
  hydra.formatting.convertCase : ((hydra.util.CaseConvention → hydra.util.CaseConvention → string → string))
  hydra.formatting.convertCaseCamelToLowerSnake : ((string → string))
  hydra.formatting.convertCaseCamelToUpperSnake : ((string → string))
  hydra.formatting.convertCasePascalToUpperSnake : ((string → string))
  hydra.formatting.decapitalize : ((string → string))
  hydra.formatting.escapeWithUnderscore : ((set<string> → string → string))
  hydra.formatting.indentLines : ((string → string))
  hydra.formatting.javaStyleComment : ((string → string))
  hydra.formatting.mapFirstLetter : (((string → string) → string → string))
  hydra.formatting.nonAlnumToUnderscores : ((string → string))
  hydra.formatting.sanitizeWithUnderscores : ((set<string> → string → string))
  hydra.formatting.showList : (∀[t0].((t0 → string) → list<t0> → string))
  hydra.formatting.stripLeadingAndTrailingWhitespace : ((string → string))
  hydra.formatting.withCharacterAliases : ((string → string))
  hydra.formatting.wrapLine : ((int32 → string → string))
  hydra.grammars.childName : ((string → string → string))
  hydra.grammars.findNames : ((list<hydra.grammar.Pattern> → list<string>))
  hydra.grammars.grammarToModule : ((hydra.module.Namespace → hydra.grammar.Grammar → maybe<string> → hydra.module.Module))
  hydra.grammars.isComplex : ((hydra.grammar.Pattern → boolean))
  hydra.grammars.isNontrivial : ((boolean → list<hydra.grammar.Pattern> → boolean))
  hydra.grammars.makeElements : ((boolean → hydra.module.Namespace → string → hydra.grammar.Pattern → list<string×hydra.core.Type>))
  hydra.grammars.rawName : ((hydra.grammar.Pattern → string))
  hydra.grammars.simplify : ((boolean → list<hydra.grammar.Pattern> → list<hydra.grammar.Pattern>))
  hydra.grammars.toName : ((hydra.module.Namespace → string → hydra.core.Name))
  hydra.grammars.wrapType : ((hydra.core.Type → hydra.core.Type))
  hydra.inference.bindConstraints : (∀[t0,t1].(hydra.typing.InferenceContext → (hydra.typing.TypeSubst → (hydra.compute.Flow @ t0 @ t1)) → list<hydra.typing.TypeConstraint> → (hydra.compute.Flow @ t0 @ t1)))
  hydra.inference.bindUnboundTypeVariables : ((hydra.typing.InferenceContext → hydra.core.Term → hydra.core.Term))
  hydra.inference.buildTypeApplicationTerm : ((list<hydra.core.Name> → hydra.core.Term → hydra.core.Term))
  hydra.inference.emptyInferenceContext : (hydra.typing.InferenceContext)
  hydra.inference.extendContext : ((list<hydra.core.Name×hydra.core.TypeScheme> → hydra.typing.InferenceContext → hydra.typing.InferenceContext))
  hydra.inference.finalizeInferredTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.inference.forInferredTerm : (∀[t0,t1].(hydra.typing.InferenceContext → hydra.core.Term → string → (hydra.typing.InferenceResult → t0) → (hydra.compute.Flow @ t1 @ t0)))
  hydra.inference.freeVariablesInContext : ((hydra.typing.InferenceContext → set<hydra.core.Name>))
  hydra.inference.freshVariableType : (∀[t0].(hydra.compute.Flow @ t0 @ hydra.core.Type))
  hydra.inference.generalize : ((hydra.typing.InferenceContext → hydra.core.Type → hydra.core.TypeScheme))
  hydra.inference.inferGraphTypes : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ hydra.graph.Graph)))
  hydra.inference.inferInGraphContext : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.typing.InferenceResult)))
  hydra.inference.inferMany : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Term×string> → (hydra.compute.Flow @ t0 @ list<hydra.core.Term>×list<hydra.core.Type>×hydra.typing.TypeSubst)))
  hydra.inference.inferTypeOf : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term×hydra.core.TypeScheme)))
  hydra.inference.inferTypeOfAnnotatedTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.AnnotatedTerm → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfApplication : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Application → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfCaseStatement : (∀[t0].(hydra.typing.InferenceContext → hydra.core.CaseStatement → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfCollection : (∀[t0].(hydra.typing.InferenceContext → (hydra.core.Type → hydra.core.Type) → (list<hydra.core.Term> → hydra.core.Term) → string → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfEither : (∀[t0].(hydra.typing.InferenceContext → either<hydra.core.Term, hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfElimination : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Elimination → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfFunction : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Function → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfInjection : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Injection → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLambda : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Lambda → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLet : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Let → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLetNormalized : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Let → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfList : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfLiteral : (∀[t0,t1].(t0 → hydra.core.Literal → (hydra.compute.Flow @ t1 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfMap : (∀[t0].(hydra.typing.InferenceContext → map<hydra.core.Term, hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfOptional : (∀[t0].(hydra.typing.InferenceContext → maybe<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfPair : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term×hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfPrimitive : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfProduct : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfProjection : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Projection → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfRecord : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Record → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfSet : (∀[t0].(hydra.typing.InferenceContext → set<hydra.core.Term> → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfSum : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Sum → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Term → string → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTupleProjection : (∀[t0,t1].(t0 → hydra.core.TupleProjection → (hydra.compute.Flow @ t1 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTypeApplication : (∀[t0].(hydra.typing.InferenceContext → hydra.core.TypeApplicationTerm → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfTypeLambda : (∀[t0].(hydra.typing.InferenceContext → hydra.core.TypeLambda → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfUnit : (hydra.typing.InferenceResult)
  hydra.inference.inferTypeOfUnwrap : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfVariable : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypeOfWrappedTerm : (∀[t0].(hydra.typing.InferenceContext → hydra.core.WrappedTerm → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.inferTypesOfTemporaryBindings : (∀[t0].(hydra.typing.InferenceContext → list<hydra.core.Binding> → (hydra.compute.Flow @ t0 @ list<hydra.core.Term>×list<hydra.core.Type>×hydra.typing.TypeSubst)))
  hydra.inference.initialTypeContext : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ hydra.typing.TypeContext)))
  hydra.inference.isUnbound : ((hydra.typing.InferenceContext → hydra.core.Name → boolean))
  hydra.inference.mapConstraints : (∀[t0,t1].(hydra.typing.InferenceContext → (hydra.typing.TypeSubst → t0) → list<hydra.typing.TypeConstraint> → (hydra.compute.Flow @ t1 @ t0)))
  hydra.inference.showInferenceResult : ((hydra.typing.InferenceResult → string))
  hydra.inference.yield : ((hydra.core.Term → hydra.core.Type → hydra.typing.TypeSubst → hydra.typing.InferenceResult))
  hydra.inference.yieldChecked : (∀[t0].(hydra.core.Term → hydra.core.Type → hydra.typing.TypeSubst → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceResult)))
  hydra.inference.yieldDebug : (∀[t0,t1,t2].(t0 → t1 → hydra.core.Term → hydra.core.Type → hydra.typing.TypeSubst → (hydra.compute.Flow @ t2 @ hydra.typing.InferenceResult)))
  hydra.languages.hydraLanguage : (hydra.coders.Language)
  hydra.lexical.dereferenceElement : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<hydra.core.Binding>)))
  hydra.lexical.dereferenceSchemaType : ((hydra.core.Name → map<hydra.core.Name, hydra.core.TypeScheme> → maybe<hydra.core.TypeScheme>))
  hydra.lexical.elementsToGraph : ((hydra.graph.Graph → maybe<hydra.graph.Graph> → list<hydra.core.Binding> → hydra.graph.Graph))
  hydra.lexical.emptyGraph : (hydra.graph.Graph)
  hydra.lexical.extendGraphWithBindings : ((list<hydra.core.Binding> → hydra.graph.Graph → hydra.graph.Graph))
  hydra.lexical.fieldsOf : ((hydra.core.Type → list<hydra.core.FieldType>))
  hydra.lexical.getField : (∀[t0,t1,t2].(map<hydra.core.Name, t0> → hydra.core.Name → (t0 → (hydra.compute.Flow @ t1 @ t2)) → (hydra.compute.Flow @ t1 @ t2)))
  hydra.lexical.lookupElement : ((hydra.graph.Graph → hydra.core.Name → maybe<hydra.core.Binding>))
  hydra.lexical.lookupPrimitive : ((hydra.graph.Graph → hydra.core.Name → maybe<hydra.graph.Primitive>))
  hydra.lexical.matchEnum : (∀[t0].(hydra.core.Name → list<hydra.core.Name×t0> → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.lexical.matchRecord : (∀[t0,t1].((map<hydra.core.Name, hydra.core.Term> → (hydra.compute.Flow @ t0 @ t1)) → hydra.core.Term → (hydra.compute.Flow @ t0 @ t1)))
  hydra.lexical.matchUnion : (∀[t0].(hydra.core.Name → list<hydra.core.Name×(hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0))> → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.lexical.matchUnitField : (∀[t0,t1,t2,t3].(t0 → t1 → t0×(t2 → (hydra.compute.Flow @ t3 @ t1))))
  hydra.lexical.requireElement : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Binding)))
  hydra.lexical.requirePrimitive : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.graph.Primitive)))
  hydra.lexical.requirePrimitiveType : (∀[t0].(hydra.typing.TypeContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.core.TypeScheme)))
  hydra.lexical.requireTerm : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.lexical.resolveTerm : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<hydra.core.Term>)))
  hydra.lexical.schemaContext : ((hydra.graph.Graph → hydra.graph.Graph))
  hydra.lexical.stripAndDereferenceTerm : ((hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.lexical.withEmptyGraph : (∀[t0,t1].((hydra.compute.Flow @ hydra.graph.Graph @ t0) → (hydra.compute.Flow @ t1 @ t0)))
  hydra.lexical.withSchemaContext : (∀[t0].((hydra.compute.Flow @ hydra.graph.Graph @ t0) → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.literals.bigfloatToFloatValue : ((hydra.core.FloatType → bigfloat → hydra.core.FloatValue))
  hydra.literals.bigintToIntegerValue : ((hydra.core.IntegerType → bigint → hydra.core.IntegerValue))
  hydra.literals.floatValueToBigfloat : ((hydra.core.FloatValue → bigfloat))
  hydra.literals.integerValueToBigint : ((hydra.core.IntegerValue → bigint))
  hydra.monads.bind : (∀[t0,t1,t2].((hydra.compute.Flow @ t0 @ t1) → (t1 → (hydra.compute.Flow @ t0 @ t2)) → (hydra.compute.Flow @ t0 @ t2)))
  hydra.monads.emptyTrace : (hydra.compute.Trace)
  hydra.monads.exec : (∀[t0,t1].((hydra.compute.Flow @ t0 @ t1) → t0 → t0))
  hydra.monads.fail : (∀[t0,t1].(string → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.flowSucceeds : (∀[t0,t1].(t0 → (hydra.compute.Flow @ t0 @ t1) → boolean))
  hydra.monads.fromFlow : (∀[t0,t1].(t0 → t1 → (hydra.compute.Flow @ t1 @ t0) → t0))
  hydra.monads.getState : (∀[t0].(hydra.compute.Flow @ t0 @ t0))
  hydra.monads.map : (∀[t0,t1,t2].((t0 → t1) → (hydra.compute.Flow @ t2 @ t0) → (hydra.compute.Flow @ t2 @ t1)))
  hydra.monads.maybeToList : (∀[t0].(maybe<t0> → list<t0>))
  hydra.monads.modify : (∀[t0].((t0 → t0) → (hydra.compute.Flow @ t0 @ unit)))
  hydra.monads.mutateTrace : (∀[t0,t1].((hydra.compute.Trace → either<string, hydra.compute.Trace>) → (hydra.compute.Trace → hydra.compute.Trace → hydra.compute.Trace) → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.pure : (∀[t0,t1].(t0 → (hydra.compute.Flow @ t1 @ t0)))
  hydra.monads.pushError : ((string → hydra.compute.Trace → hydra.compute.Trace))
  hydra.monads.putState : (∀[t0].(t0 → (hydra.compute.Flow @ t0 @ unit)))
  hydra.monads.traceSummary : ((hydra.compute.Trace → string))
  hydra.monads.unexpected : (∀[t0,t1].(string → string → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.warn : (∀[t0,t1].(string → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.withFlag : (∀[t0,t1].(hydra.core.Name → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.monads.withState : (∀[t0,t1,t2].(t0 → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t2 @ t1)))
  hydra.monads.withTrace : (∀[t0,t1].(string → (hydra.compute.Flow @ t0 @ t1) → (hydra.compute.Flow @ t0 @ t1)))
  hydra.names.compactName : ((map<hydra.module.Namespace, string> → hydra.core.Name → string))
  hydra.names.localNameOf : ((hydra.core.Name → string))
  hydra.names.namespaceOf : ((hydra.core.Name → maybe<hydra.module.Namespace>))
  hydra.names.namespaceToFilePath : ((hydra.util.CaseConvention → hydra.module.FileExtension → hydra.module.Namespace → string))
  hydra.names.qname : ((hydra.module.Namespace → string → hydra.core.Name))
  hydra.names.qualifyName : ((hydra.core.Name → hydra.module.QualifiedName))
  hydra.names.uniqueLabel : ((set<string> → string → string))
  hydra.names.unqualifyName : ((hydra.module.QualifiedName → hydra.core.Name))
  hydra.reduction.alphaConvert : ((hydra.core.Name → hydra.core.Name → hydra.core.Term → hydra.core.Term))
  hydra.reduction.betaReduceType : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.reduction.contractTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.reduction.countPrimitiveInvocations : (boolean)
  hydra.reduction.etaExpandTerm : ((hydra.graph.Graph → hydra.core.Term → hydra.core.Term))
  hydra.reduction.etaExpandTypedTerm : (∀[t0].(hydra.typing.TypeContext → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.reduction.etaExpansionArity : ((hydra.graph.Graph → hydra.core.Term → int32))
  hydra.reduction.etaReduceTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.reduction.reduceTerm : ((boolean → hydra.core.Term → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Term)))
  hydra.reduction.termIsClosed : ((hydra.core.Term → boolean))
  hydra.reduction.termIsValue : (∀[t0].(t0 → hydra.core.Term → boolean))
  hydra.rewriting.deannotateAndDetypeTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.deannotateTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.deannotateType : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.deannotateTypeParameters : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.deannotateTypeRecursive : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.deannotateTypeSchemeRecursive : ((hydra.core.TypeScheme → hydra.core.TypeScheme))
  hydra.rewriting.detypeTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.flattenLetTerms : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.foldOverTerm : (∀[t0].(hydra.coders.TraversalOrder → (t0 → hydra.core.Term → t0) → t0 → hydra.core.Term → t0))
  hydra.rewriting.foldOverType : (∀[t0].(hydra.coders.TraversalOrder → (t0 → hydra.core.Type → t0) → t0 → hydra.core.Type → t0))
  hydra.rewriting.freeTypeVariablesInTerm : ((hydra.core.Term → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTerm : ((hydra.core.Term → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInType : ((hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeOrdered : ((hydra.core.Type → list<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeScheme : ((hydra.core.TypeScheme → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeSchemeSimple : ((hydra.core.TypeScheme → set<hydra.core.Name>))
  hydra.rewriting.freeVariablesInTypeSimple : ((hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.inlineType : (∀[t0].(map<hydra.core.Name, hydra.core.Type> → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.rewriting.isFreeVariableInTerm : ((hydra.core.Name → hydra.core.Term → boolean))
  hydra.rewriting.isLambda : ((hydra.core.Term → boolean))
  hydra.rewriting.liftLambdaAboveLet : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.mapBeneathTypeAnnotations : (((hydra.core.Type → hydra.core.Type) → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.normalizeTypeVariablesInTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.removeTermAnnotations : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.removeTypeAnnotations : ((hydra.core.Type → hydra.core.Type))
  hydra.rewriting.removeTypesFromTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.replaceFreeTermVariable : ((hydra.core.Name → hydra.core.Term → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.replaceFreeTypeVariable : ((hydra.core.Name → hydra.core.Type → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.replaceTypedefs : ((map<hydra.core.Name, hydra.core.TypeScheme> → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.rewriteAndFoldTerm : (∀[t0].(((t0 → hydra.core.Term → t0×hydra.core.Term) → t0 → hydra.core.Term → t0×hydra.core.Term) → t0 → hydra.core.Term → t0×hydra.core.Term))
  hydra.rewriting.rewriteAndFoldTermM : (∀[t0,t1].(((t0 → hydra.core.Term → (hydra.compute.Flow @ t1 @ t0×hydra.core.Term)) → t0 → hydra.core.Term → (hydra.compute.Flow @ t1 @ t0×hydra.core.Term)) → t0 → hydra.core.Term → (hydra.compute.Flow @ t1 @ t0×hydra.core.Term)))
  hydra.rewriting.rewriteTerm : ((((hydra.core.Term → hydra.core.Term) → hydra.core.Term → hydra.core.Term) → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.rewriteTermM : (∀[t0].(((hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)) → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)) → hydra.core.Term → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.rewriting.rewriteTermWithContext : (∀[t0].(((t0 → hydra.core.Term → hydra.core.Term) → t0 → hydra.core.Term → hydra.core.Term) → t0 → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.rewriteTermWithContextM : (∀[t0,t1].(((t0 → hydra.core.Term → (hydra.compute.Flow @ t1 @ hydra.core.Term)) → t0 → hydra.core.Term → (hydra.compute.Flow @ t1 @ hydra.core.Term)) → t0 → hydra.core.Term → (hydra.compute.Flow @ t1 @ hydra.core.Term)))
  hydra.rewriting.rewriteType : ((((hydra.core.Type → hydra.core.Type) → hydra.core.Type → hydra.core.Type) → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.rewriteTypeM : (∀[t0].(((hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)) → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)) → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.rewriting.simplifyTerm : ((hydra.core.Term → hydra.core.Term))
  hydra.rewriting.substituteTypeVariables : ((map<hydra.core.Name, hydra.core.Name> → hydra.core.Type → hydra.core.Type))
  hydra.rewriting.substituteVariable : ((hydra.core.Name → hydra.core.Name → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.substituteVariables : ((map<hydra.core.Name, hydra.core.Name> → hydra.core.Term → hydra.core.Term))
  hydra.rewriting.subterms : ((hydra.core.Term → list<hydra.core.Term>))
  hydra.rewriting.subtermsWithAccessors : ((hydra.core.Term → list<hydra.accessors.TermAccessor×hydra.core.Term>))
  hydra.rewriting.subtypes : ((hydra.core.Type → list<hydra.core.Type>))
  hydra.rewriting.termDependencyNames : ((boolean → boolean → boolean → hydra.core.Term → set<hydra.core.Name>))
  hydra.rewriting.toShortNames : ((list<hydra.core.Name> → map<hydra.core.Name, hydra.core.Name>))
  hydra.rewriting.topologicalSortBindingMap : ((map<hydra.core.Name, hydra.core.Term> → list<list<hydra.core.Name×hydra.core.Term>>))
  hydra.rewriting.topologicalSortBindings : ((list<hydra.core.Binding> → either<list<list<hydra.core.Name>>, list<hydra.core.Name>>))
  hydra.rewriting.typeDependencyNames : ((boolean → hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.typeNamesInType : ((hydra.core.Type → set<hydra.core.Name>))
  hydra.rewriting.unshadowVariables : ((hydra.core.Term → hydra.core.Term))
  hydra.schemas.addNamesToNamespaces : (∀[t0].((hydra.module.Namespace → t0) → set<hydra.core.Name> → (hydra.module.Namespaces @ t0) → (hydra.module.Namespaces @ t0)))
  hydra.schemas.definitionDependencyNamespaces : ((list<hydra.module.Definition> → set<hydra.module.Namespace>))
  hydra.schemas.dependencyNamespaces : ((boolean → boolean → boolean → boolean → list<hydra.core.Binding> → (hydra.compute.Flow @ hydra.graph.Graph @ set<hydra.module.Namespace>)))
  hydra.schemas.dereferenceType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<hydra.core.Type>)))
  hydra.schemas.elementAsTypeApplicationTerm : (∀[t0].(hydra.core.Binding → (hydra.compute.Flow @ t0 @ hydra.core.TypeApplicationTerm)))
  hydra.schemas.elementsWithDependencies : ((list<hydra.core.Binding> → (hydra.compute.Flow @ hydra.graph.Graph @ list<hydra.core.Binding>)))
  hydra.schemas.extendTypeContextForLambda : ((hydra.typing.TypeContext → hydra.core.Lambda → hydra.typing.TypeContext))
  hydra.schemas.extendTypeContextForLet : ((hydra.typing.TypeContext → hydra.core.Let → hydra.typing.TypeContext))
  hydra.schemas.extendTypeContextForTypeLambda : ((hydra.typing.TypeContext → hydra.core.TypeLambda → hydra.typing.TypeContext))
  hydra.schemas.fTypeToTypeScheme : ((hydra.core.Type → hydra.core.TypeScheme))
  hydra.schemas.fieldMap : ((list<hydra.core.Field> → map<hydra.core.Name, hydra.core.Term>))
  hydra.schemas.fieldTypeMap : ((list<hydra.core.FieldType> → map<hydra.core.Name, hydra.core.Type>))
  hydra.schemas.fieldTypes : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.schemas.findFieldType : (∀[t0].(hydra.core.Name → list<hydra.core.FieldType> → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.schemas.freshName : (∀[t0].(hydra.compute.Flow @ t0 @ hydra.core.Name))
  hydra.schemas.freshNames : (∀[t0].(int32 → (hydra.compute.Flow @ t0 @ list<hydra.core.Name>)))
  hydra.schemas.fullyStripType : ((hydra.core.Type → hydra.core.Type))
  hydra.schemas.graphAsTerm : ((hydra.graph.Graph → hydra.core.Term))
  hydra.schemas.graphAsTypes : ((hydra.graph.Graph → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.schemas.graphToInferenceContext : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ hydra.typing.InferenceContext)))
  hydra.schemas.graphToTypeContext : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ hydra.typing.TypeContext)))
  hydra.schemas.instantiateType : (∀[t0].(hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Type)))
  hydra.schemas.instantiateTypeScheme : (∀[t0].(hydra.core.TypeScheme → (hydra.compute.Flow @ t0 @ hydra.core.TypeScheme)))
  hydra.schemas.isEnumRowType : ((hydra.core.RowType → boolean))
  hydra.schemas.isEnumType : ((hydra.core.Type → boolean))
  hydra.schemas.isSerializable : ((hydra.core.Binding → (hydra.compute.Flow @ hydra.graph.Graph @ boolean)))
  hydra.schemas.moduleDependencyNamespaces : ((boolean → boolean → boolean → boolean → hydra.module.Module → (hydra.compute.Flow @ hydra.graph.Graph @ set<hydra.module.Namespace>)))
  hydra.schemas.namespacesForDefinitions : (∀[t0].((hydra.module.Namespace → t0) → hydra.module.Namespace → list<hydra.module.Definition> → (hydra.module.Namespaces @ t0)))
  hydra.schemas.nominalApplication : ((hydra.core.Name → list<hydra.core.Type> → hydra.core.Type))
  hydra.schemas.normalTypeVariable : ((int32 → hydra.core.Name))
  hydra.schemas.requireRecordType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.RowType)))
  hydra.schemas.requireRowType : (∀[t0].(string → (hydra.core.Type → maybe<t0>) → hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ t0)))
  hydra.schemas.requireSchemaType : (∀[t0].(hydra.typing.InferenceContext → hydra.core.Name → (hydra.compute.Flow @ t0 @ hydra.core.TypeScheme)))
  hydra.schemas.requireType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.Type)))
  hydra.schemas.requireUnionType : ((hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ hydra.core.RowType)))
  hydra.schemas.resolveType : ((hydra.core.Type → (hydra.compute.Flow @ hydra.graph.Graph @ maybe<hydra.core.Type>)))
  hydra.schemas.schemaGraphToTypingEnvironment : (∀[t0].(hydra.graph.Graph → (hydra.compute.Flow @ t0 @ map<hydra.core.Name, hydra.core.TypeScheme>)))
  hydra.schemas.termAsGraph : ((hydra.core.Term → map<hydra.core.Name, hydra.core.Binding>))
  hydra.schemas.topologicalSortTypeDefinitions : ((list<hydra.module.TypeDefinition> → list<list<hydra.module.TypeDefinition>>))
  hydra.schemas.typeDependencies : ((boolean → (hydra.core.Type → hydra.core.Type) → hydra.core.Name → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.schemas.typeSchemeToFType : ((hydra.core.TypeScheme → hydra.core.Type))
  hydra.schemas.typeToTypeScheme : ((hydra.core.Type → hydra.core.TypeScheme))
  hydra.schemas.typesToElements : ((map<hydra.core.Name, hydra.core.Type> → map<hydra.core.Name, hydra.core.Binding>))
  hydra.serialization.angleBraces : (hydra.ast.Brackets)
  hydra.serialization.angleBracesList : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.bracesListAdaptive : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.bracketList : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.bracketListAdaptive : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.brackets : ((hydra.ast.Brackets → hydra.ast.BlockStyle → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.commaSep : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.cst : ((string → hydra.ast.Expr))
  hydra.serialization.curlyBlock : ((hydra.ast.BlockStyle → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.curlyBraces : (hydra.ast.Brackets)
  hydra.serialization.curlyBracesList : ((maybe<string> → hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.customIndent : ((string → string → string))
  hydra.serialization.customIndentBlock : ((string → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.dotSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.doubleNewlineSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.doubleSpace : (string)
  hydra.serialization.expressionLength : ((hydra.ast.Expr → int32))
  hydra.serialization.fullBlockStyle : (hydra.ast.BlockStyle)
  hydra.serialization.halfBlockStyle : (hydra.ast.BlockStyle)
  hydra.serialization.ifx : ((hydra.ast.Op → hydra.ast.Expr → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.indent : ((string → string))
  hydra.serialization.indentBlock : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.indentSubsequentLines : ((string → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.infixWs : ((string → hydra.ast.Expr → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.infixWsList : ((string → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.inlineStyle : (hydra.ast.BlockStyle)
  hydra.serialization.newlineSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.noPadding : (hydra.ast.Padding)
  hydra.serialization.noSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.num : ((int32 → hydra.ast.Expr))
  hydra.serialization.op : ((string → int32 → hydra.ast.Associativity → hydra.ast.Op))
  hydra.serialization.orOp : ((boolean → hydra.ast.Op))
  hydra.serialization.orSep : ((hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.parenList : ((boolean → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.parens : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.parentheses : (hydra.ast.Brackets)
  hydra.serialization.parenthesize : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.prefix : ((string → hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.printExpr : ((hydra.ast.Expr → string))
  hydra.serialization.semicolonSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.sep : ((hydra.ast.Op → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.spaceSep : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.squareBrackets : (hydra.ast.Brackets)
  hydra.serialization.sym : ((string → hydra.ast.Symbol))
  hydra.serialization.symbolSep : ((string → hydra.ast.BlockStyle → list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.tabIndent : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.tabIndentDoubleSpace : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.tabIndentSingleSpace : ((list<hydra.ast.Expr> → hydra.ast.Expr))
  hydra.serialization.unsupportedType : ((string → hydra.ast.Expr))
  hydra.serialization.unsupportedVariant : ((string → string → hydra.ast.Expr))
  hydra.serialization.withComma : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.serialization.withSemi : ((hydra.ast.Expr → hydra.ast.Expr))
  hydra.show.accessors.termAccessor : ((hydra.accessors.TermAccessor → maybe<string>))
  hydra.show.accessors.termToAccessorGraph : ((map<hydra.module.Namespace, string> → hydra.core.Term → hydra.accessors.AccessorGraph))
  hydra.show.core.binding : ((hydra.core.Binding → string))
  hydra.show.core.elimination : ((hydra.core.Elimination → string))
  hydra.show.core.field : ((hydra.core.Field → string))
  hydra.show.core.fieldType : ((hydra.core.FieldType → string))
  hydra.show.core.fields : ((list<hydra.core.Field> → string))
  hydra.show.core.float : ((hydra.core.FloatValue → string))
  hydra.show.core.floatType : ((hydra.core.FloatType → string))
  hydra.show.core.function : ((hydra.core.Function → string))
  hydra.show.core.injection : ((hydra.core.Injection → string))
  hydra.show.core.integer : ((hydra.core.IntegerValue → string))
  hydra.show.core.integerType : ((hydra.core.IntegerType → string))
  hydra.show.core.lambda : ((hydra.core.Lambda → string))
  hydra.show.core.list : (∀[t0].((t0 → string) → list<t0> → string))
  hydra.show.core.literal : ((hydra.core.Literal → string))
  hydra.show.core.literalType : ((hydra.core.LiteralType → string))
  hydra.show.core.readTerm : ((string → maybe<hydra.core.Term>))
  hydra.show.core.term : ((hydra.core.Term → string))
  hydra.show.core.type : ((hydra.core.Type → string))
  hydra.show.core.typeScheme : ((hydra.core.TypeScheme → string))
  hydra.show.graph.graph : ((hydra.graph.Graph → string))
  hydra.show.meta.termVariant : ((hydra.meta.TermVariant → string))
  hydra.show.meta.typeVariant : ((hydra.meta.TypeVariant → string))
  hydra.show.typing.typeConstraint : ((hydra.typing.TypeConstraint → string))
  hydra.show.typing.typeSubst : ((hydra.typing.TypeSubst → string))
  hydra.sorting.createOrderingIsomorphism : (∀[t0,t1].(list<t0> → list<t0> → (hydra.topology.OrderingIsomorphism @ t1)))
  hydra.sorting.topologicalSort : (∀[t0].(list<t0×list<t0>> → either<list<list<t0>>, list<t0>>))
  hydra.sorting.topologicalSortComponents : (∀[t0].(list<t0×list<t0>> → list<list<t0>>))
  hydra.sorting.topologicalSortNodes : (∀[t0,t1].((t0 → t1) → (t0 → list<t1>) → list<t0> → list<list<t0>>))
  hydra.substitution.composeTypeSubst : ((hydra.typing.TypeSubst → hydra.typing.TypeSubst → hydra.typing.TypeSubst))
  hydra.substitution.composeTypeSubstList : ((list<hydra.typing.TypeSubst> → hydra.typing.TypeSubst))
  hydra.substitution.idTypeSubst : (hydra.typing.TypeSubst)
  hydra.substitution.singletonTypeSubst : ((hydra.core.Name → hydra.core.Type → hydra.typing.TypeSubst))
  hydra.substitution.substInContext : ((hydra.typing.TypeSubst → hydra.typing.InferenceContext → hydra.typing.InferenceContext))
  hydra.substitution.substInType : ((hydra.typing.TypeSubst → hydra.core.Type → hydra.core.Type))
  hydra.substitution.substInTypeScheme : ((hydra.typing.TypeSubst → hydra.core.TypeScheme → hydra.core.TypeScheme))
  hydra.substitution.substTypesInTerm : ((hydra.typing.TypeSubst → hydra.core.Term → hydra.core.Term))
  hydra.substitution.substituteInConstraint : ((hydra.typing.TypeSubst → hydra.typing.TypeConstraint → hydra.typing.TypeConstraint))
  hydra.substitution.substituteInConstraints : ((hydra.typing.TypeSubst → list<hydra.typing.TypeConstraint> → list<hydra.typing.TypeConstraint>))
  hydra.substitution.substituteInTerm : ((hydra.typing.TermSubst → hydra.core.Term → hydra.core.Term))
  hydra.tarjan.adjacencyListsToGraph : (∀[t0].(list<t0×list<t0>> → map<int32, list<int32>>×(int32 → t0)))
  hydra.tarjan.initialState : (hydra.topology.TarjanState)
  hydra.tarjan.popStackUntil : ((int32 → (hydra.compute.Flow @ hydra.topology.TarjanState @ list<int32>)))
  hydra.tarjan.strongConnect : ((map<int32, list<int32>> → int32 → (hydra.compute.Flow @ hydra.topology.TarjanState @ unit)))
  hydra.tarjan.stronglyConnectedComponents : ((map<int32, list<int32>> → list<list<int32>>))
  hydra.templates.graphToSchema : ((hydra.graph.Graph → (hydra.compute.Flow @ hydra.graph.Graph @ map<hydra.core.Name, hydra.core.Type>)))
  hydra.templates.instantiateTemplate : (∀[t0].(boolean → map<hydra.core.Name, hydra.core.Type> → hydra.core.Type → (hydra.compute.Flow @ t0 @ hydra.core.Term)))
  hydra.unification.joinTypes : (∀[t0].(hydra.core.Type → hydra.core.Type → string → (hydra.compute.Flow @ t0 @ list<hydra.typing.TypeConstraint>)))
  hydra.unification.unifyTypeConstraints : (∀[t0,t1].(map<hydra.core.Name, t0> → list<hydra.typing.TypeConstraint> → (hydra.compute.Flow @ t1 @ hydra.typing.TypeSubst)))
  hydra.unification.unifyTypeLists : (∀[t0,t1].(map<hydra.core.Name, t0> → list<hydra.core.Type> → list<hydra.core.Type> → string → (hydra.compute.Flow @ t1 @ hydra.typing.TypeSubst)))
  hydra.unification.unifyTypes : (∀[t0,t1].(map<hydra.core.Name, t0> → hydra.core.Type → hydra.core.Type → string → (hydra.compute.Flow @ t1 @ hydra.typing.TypeSubst)))
  hydra.unification.variableOccursInType : ((hydra.core.Name → hydra.core.Type → boolean))
  hydra.variants.eliminationVariant : ((hydra.core.Elimination → hydra.meta.EliminationVariant))
  hydra.variants.eliminationVariants : (list<hydra.meta.EliminationVariant>)
  hydra.variants.floatTypePrecision : ((hydra.core.FloatType → hydra.util.Precision))
  hydra.variants.floatTypes : (list<hydra.core.FloatType>)
  hydra.variants.floatValueType : ((hydra.core.FloatValue → hydra.core.FloatType))
  hydra.variants.functionVariant : ((hydra.core.Function → hydra.meta.FunctionVariant))
  hydra.variants.functionVariants : (list<hydra.meta.FunctionVariant>)
  hydra.variants.integerTypeIsSigned : ((hydra.core.IntegerType → boolean))
  hydra.variants.integerTypePrecision : ((hydra.core.IntegerType → hydra.util.Precision))
  hydra.variants.integerTypes : (list<hydra.core.IntegerType>)
  hydra.variants.integerValueType : ((hydra.core.IntegerValue → hydra.core.IntegerType))
  hydra.variants.literalType : ((hydra.core.Literal → hydra.core.LiteralType))
  hydra.variants.literalTypeVariant : ((hydra.core.LiteralType → hydra.meta.LiteralVariant))
  hydra.variants.literalTypes : (list<hydra.core.LiteralType>)
  hydra.variants.literalVariant : ((hydra.core.Literal → hydra.meta.LiteralVariant))
  hydra.variants.literalVariants : (list<hydra.meta.LiteralVariant>)
  hydra.variants.termVariant : ((hydra.core.Term → hydra.meta.TermVariant))
  hydra.variants.termVariants : (list<hydra.meta.TermVariant>)
  hydra.variants.typeVariant : ((hydra.core.Type → hydra.meta.TypeVariant))
  hydra.variants.typeVariants : (list<hydra.meta.TypeVariant>)
