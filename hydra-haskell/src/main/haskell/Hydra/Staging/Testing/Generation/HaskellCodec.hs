module Hydra.Staging.Testing.Generation.HaskellCodec where

import Hydra.Kernel hiding (map)
import Hydra.Testing
import Hydra.Coders (LanguageName(..))
import Hydra.Staging.Testing.Generation.Transform (collectTestCases, addGenerationPrefix)
import Hydra.Staging.Testing.Generation.Generate (TestGenerator(..), createTestGroupLookup, generateGenerationTestSuite)
import qualified Hydra.Ext.Haskell.Coder as HaskellCoder
import Hydra.Ext.Haskell.Utils (namespacesForModule, sanitizeHaskellName)
import qualified Hydra.Ext.Haskell.Serde as HaskellSerde
import Hydra.Serialization (printExpr, parenthesize)
import qualified Hydra.Ext.Haskell.Ast as H
import qualified Hydra.Names as Names
import qualified Hydra.Util as Util
import qualified Hydra.Show.Core as ShowCore
import qualified Hydra.Formatting as Formatting
import qualified Hydra.Lib.Strings as Strings
import qualified Hydra.Lib.Lists as Lists

import qualified Data.Map as M
import qualified Data.List as L
import qualified Data.Set as S
import qualified Hydra.Rewriting as Rewriting
import qualified Hydra.Inference as Inference
import qualified Hydra.Substitution as Substitution
import qualified Hydra.Typing as Typing
import Debug.Trace
import Data.Char (toUpper)
import qualified System.FilePath as FP


termToHaskell :: Namespaces H.ModuleName -> Term -> Flow Graph String
termToHaskell namespaces term = (printExpr . parenthesize . HaskellSerde.expressionToExpr) <$>
  HaskellCoder.encodeTerm namespaces term

typeToHaskell :: Namespaces H.ModuleName -> Type -> Flow Graph String
typeToHaskell namespaces typ = (printExpr . parenthesize . HaskellSerde.typeToExpr) <$>
  HaskellCoder.encodeType namespaces typ

-- | Create a Haskell TestCodec that uses the real Haskell coder
haskellTestCodec :: Namespaces H.ModuleName -> TestCodec
haskellTestCodec namespaces = TestCodec {
    testCodecLanguage = LanguageName "haskell",
    testCodecFileExtension = FileExtension "hs",
    testCodecEncodeTerm = termToHaskell namespaces,
    testCodecEncodeType = typeToHaskell namespaces,
    testCodecFormatTestName = id,  -- Keep test names as-is
    testCodecFormatModuleName = namespaceToModuleName,
    testCodecTestCaseTemplate = haskellTestCaseTemplate,
    testCodecTestGroupTemplate = haskellTestGroupTemplate,
    testCodecModuleTemplate = haskellModuleTemplate,
    testCodecImportTemplate = haskellImportTemplate,
    testCodecFindImports = findHaskellImports namespaces}

-- Templates for Haskell test generation
haskellTestCaseTemplate :: String
haskellTestCaseTemplate = unlines [
  "  H.it {name} $ H.shouldBe",
  "    ({input})",
  "    ({output})"]

haskellTestGroupTemplate :: String
haskellTestGroupTemplate = "spec = H.describe {groupName} $ do"

haskellModuleTemplate :: String
haskellModuleTemplate = unlines [
  "-- " ++ warningAutoGeneratedFile,
  "",
  "module {moduleName} where",
  "",
  "{imports}",
  "",
  "spec :: H.Spec",
  "{testGroup}",
  "{testCases}"]

haskellImportTemplate :: String
haskellImportTemplate = "import qualified {namespace} as {alias}"

-- | Find necessary imports for Haskell based on referenced names
findHaskellImports :: Namespaces H.ModuleName -> S.Set Name -> [String]
findHaskellImports namespaces names = L.map makeImport (M.toList filteredMapping)
  where
    -- Filter out test module namespaces (hydra.test.*) which aren't in main library
    isTestNamespace (Namespace ns) = "hydra.test." `L.isPrefixOf` ns
    filteredMapping = M.filterWithKey (\ns _ -> not (isTestNamespace ns)) (namespacesMapping namespaces)
    makeImport (ns, alias) =
      "import qualified " ++ nsToModuleName ns ++ " as " ++ H.unModuleName alias
    nsToModuleName (Namespace ns) =
      Strings.intercalate "." $ Lists.map Formatting.capitalize (Strings.splitOn "." ns)

-- | Generate test hierarchy preserving the structure with H.describe blocks for subgroups
generateTestGroupHierarchy :: InferenceContext -> Namespaces H.ModuleName -> TestCodec -> Int -> TestGroup -> Flow Graph String
generateTestGroupHierarchy infContext namespaces codec depth testGroup = do
  -- Generate test cases at the current level with proper indentation
  testCaseLinesRaw <- mapM (generateTestCaseWithCodec infContext namespaces codec depth) (testGroupCases testGroup)
  let indent = replicate (depth * 2) ' '
      indentTestCase = L.map (indent ++)
      testCaseLines = fmap indentTestCase testCaseLinesRaw
      testCasesStr = L.intercalate "\n" (concat testCaseLines)

  -- Generate H.describe blocks for each subgroup
  subgroupStrs <- mapM generateSubgroupBlock (testGroupSubgroups testGroup)
  let subgroupsStr = L.intercalate "\n" subgroupStrs

  -- Combine test cases and subgroups
  return $ testCasesStr ++ (if null testCasesStr || null subgroupsStr then "" else "\n") ++ subgroupsStr
  where
    generateSubgroupBlock :: TestGroup -> Flow Graph String
    generateSubgroupBlock subgroup = do
      let indent = replicate (depth * 2) ' '
      -- Recursively generate content for this subgroup at depth+1 (nested inside this H.describe)
      subgroupContent <- generateTestGroupHierarchy infContext namespaces codec (depth + 1) subgroup
      let groupName = testGroupName subgroup
      -- Generate the H.describe block with proper indentation
      return $ indent ++ "H.describe " ++ show groupName ++ " $ do\n" ++ subgroupContent

-- | Generic test file generation using a TestCodec
generateTestFileWithCodec :: TestCodec -> Module -> TestGroup -> Namespaces H.ModuleName -> Flow Graph (FilePath, String)
generateTestFileWithCodec codec testModule testGroup namespaces = do
  -- Note: Type inference is now performed ONCE upfront in generateAllModuleTests (Generate.hs)
  -- This is critical for performance: inferGraphTypes is expensive and should not be called per-module
  g <- getState
  infContext <- graphToInferenceContext g

  -- Generate test hierarchy preserving the structure
  testBody <- generateTestGroupHierarchy infContext namespaces codec 1 testGroup

  -- Build the complete test module
  let testModuleContent = buildTestModuleWithCodec codec testModule testGroup testBody namespaces

  -- Use the codec's file extension for the path
  -- Append "Spec" to the namespace for hspec-discover compatibility
  let FileExtension ext = testCodecFileExtension codec
  let Namespace ns = moduleNamespace testModule
  let specNs = Namespace (ns ++ "Spec")
  let filePath = Names.namespaceToFilePath Util.CaseConventionPascal
                   (FileExtension ext)
                   specNs

  return (filePath, testModuleContent)

-- | Generate a single test case using a TestCodec
generateTestCaseWithCodec :: InferenceContext -> Namespaces H.ModuleName -> TestCodec -> Int -> TestCaseWithMetadata -> Flow Graph [String]
generateTestCaseWithCodec infContext namespaces codec depth (TestCaseWithMetadata name tcase _ _) = case tcase of
  TestCaseDelegatedEvaluation (DelegatedEvaluationTestCase input output) -> do

    inputCode <- testCodecEncodeTerm codec input
    outputCode <- testCodecEncodeTerm codec output

    -- Format the test name using the codec
    let formattedName = testCodecFormatTestName codec name
        -- Helper to indent continuation lines to maintain alignment with opening paren
        indentLines n s = L.intercalate ("\n" ++ replicate n ' ') (L.lines s)
        -- Continuation lines need: depth*2 (base indent) + 2 ("  (" prefix) + 2 (alignment)
        continuationIndent = depth * 2 + 4
        indentedInputCode = indentLines continuationIndent inputCode
        indentedOutputCode = indentLines continuationIndent outputCode

    -- Check if output needs a type annotation (only when BOTH input and output are polymorphic)
    graph <- getState
    typeAnnotation <- generateTypeAnnotationFor infContext namespaces input output
    let (finalInputCode, finalOutputCode) = case typeAnnotation of
          Just anno -> (indentedInputCode, indentedOutputCode ++ anno)
          Nothing -> (indentedInputCode, indentedOutputCode)

    return [
      "H.it " ++ show formattedName ++ " $ H.shouldBe",
      "  (" ++ finalInputCode ++ ")",
      "  (" ++ finalOutputCode ++ ")"]

  _ -> return []  -- Skip non-delegated tests (shouldn't happen after transform)

-- | Generate a type annotation for polymorphic output values
-- Adds annotations when BOTH:
-- 1. The inferred type has free type variables that GHC cannot resolve
-- 2. The output has no concrete values to guide type inference (empty list, etc.)
--
-- The annotation is derived from the INPUT term's inferred type, since the input
-- is the expression being evaluated and its result type should match the output type.
-- Free type variables are replaced with Int32.
generateTypeAnnotationFor :: InferenceContext -> Namespaces H.ModuleName -> Term -> Term -> Flow Graph (Maybe String)
generateTypeAnnotationFor infContext namespaces inputTerm outputTerm = do
  -- Only consider annotation if output has no concrete values to guide inference
  if not (containsTriviallyPolymorphic outputTerm)
    then return Nothing
    else do
      -- Infer the type of the input expression (which gives us the result/output type)
      result <- Inference.inferTypeOf infContext inputTerm
      let (_, typeScheme) = result
          typ = typeSchemeType typeScheme
          -- Check if there are any free type variables that need grounding
          freeVars = S.toList $ S.difference
            (Rewriting.freeVariablesInType typ)
            schemaVars
      if null freeVars
        then return Nothing  -- No free variables, no annotation needed
        else do
          -- Replace free type variables with Int32
          let int32Type = TypeLiteral (LiteralTypeInteger IntegerTypeInt32)
              subst = Typing.TypeSubst $ M.fromList [(v, int32Type) | v <- freeVars]
              groundedType = Substitution.substInType subst typ
          -- Encode the type as Haskell
          typeStr <- typeToHaskell namespaces groundedType
          return $ Just (" :: " ++ typeStr)
  where
    schemaVars = S.fromList $ M.keys $ inferenceContextSchemaTypes infContext

-- | Check if a term CONTAINS any trivially polymorphic sub-terms (empty list, Nothing, etc.)
-- This recursively searches through the term structure to find any parts that would
-- cause GHC to need type annotations.
containsTriviallyPolymorphic :: Term -> Bool
containsTriviallyPolymorphic term = case term of
  TermList [] -> True  -- Empty list
  TermList xs -> any containsTriviallyPolymorphic xs  -- Check list elements
  TermSet s -> S.null s || any containsTriviallyPolymorphic (S.toList s)  -- Empty set or elements
  TermMap m -> M.null m || any containsTriviallyPolymorphic (M.keys m) || any containsTriviallyPolymorphic (M.elems m)
  TermMaybe Nothing -> True  -- Nothing value
  TermMaybe (Just x) -> containsTriviallyPolymorphic x  -- Check content
  TermEither (Left l) -> containsTriviallyPolymorphic l
  TermEither (Right r) -> containsTriviallyPolymorphic r
  TermUnion inj -> containsTriviallyPolymorphic (fieldTerm $ injectionField inj)
  TermPair (a, b) -> containsTriviallyPolymorphic a || containsTriviallyPolymorphic b
  TermRecord fields -> any (containsTriviallyPolymorphic . fieldTerm) (recordFields fields)
  TermApplication app -> containsTriviallyPolymorphic (applicationFunction app) ||
                         containsTriviallyPolymorphic (applicationArgument app)
  _ -> False

-- | Build the complete test module using a TestCodec
buildTestModuleWithCodec :: TestCodec -> Module -> TestGroup -> String -> Namespaces H.ModuleName -> String
buildTestModuleWithCodec codec testModule testGroup testBody namespaces = header ++ testBody ++ "\n"
  where
    -- Append "Spec" to module name for hspec-discover compatibility
    Namespace ns = moduleNamespace testModule
    specNs = Namespace (ns ++ "Spec")
    moduleNameString = testCodecFormatModuleName codec specNs
    groupName = testGroupName testGroup

    -- Use the codec's findImports to determine necessary imports
    -- For now, we'll pass an empty set since we're not tracking names yet
    -- TODO: collect names from test cases
    domainImports = testCodecFindImports codec S.empty

    -- Standard imports that are always needed for Haskell
    standardImports = [
      "import Hydra.Kernel",
      "import qualified Test.Hspec as H",
      "import qualified Data.List as L",
      "import qualified Data.Map as M",
      "import qualified Data.Set as S",
      "import qualified Data.Maybe as Y"]

    allImports = standardImports ++ domainImports

    -- Debug comments showing namespace configuration
    debugComments = [
        "-- DEBUG: Focus namespace = " ++ show (namespacesFocus namespaces),
        "-- DEBUG: Namespace mappings:",
        "-- " ++ show (M.toList $ namespacesMapping namespaces)
      ]

    header = unlines ([
        "-- " ++ warningAutoGeneratedFile,
        ""
      ] ++ debugComments ++ [
        "",
        "module " ++ moduleNameString ++ " where",
        ""
      ] ++ allImports ++ [
        "",
        "spec :: H.Spec",
        "spec = H.describe " ++ show groupName ++ " $ do"
      ])

-- | Convert namespace to Haskell module name
-- Uses the same logic as the Haskell coder's importName function
namespaceToModuleName :: Namespace -> String
namespaceToModuleName (Namespace ns) =
  Strings.intercalate "." $ Lists.map Formatting.capitalize (Strings.splitOn "." ns)

-- | Generate generation test file for a test group using the Haskell codec
generateHaskellTestFile :: Module -> TestGroup -> Flow Graph (FilePath, String)
generateHaskellTestFile testModule testGroup = do
  -- Build proper namespaces that include all primitives referenced in test terms
  namespaces <- buildNamespacesForTestGroup testModule testGroup

  -- Generate test file using the codec
  generateTestFileWithCodec (haskellTestCodec namespaces) testModule testGroup namespaces
  where
    buildNamespacesForTestGroup mod tgroup = do
      let testCases = collectTestCases tgroup
          testTerms = concatMap extractTestTerms testCases
          testBindings = zipWith (\i term -> Binding (Name $ "_test_" ++ show i) term Nothing) ([0..] :: [Integer]) testTerms
          tempModule = mod { moduleElements = testBindings }
      namespacesForModule tempModule
    extractTestTerms (TestCaseWithMetadata _ tcase _ _) = case tcase of
      TestCaseDelegatedEvaluation (DelegatedEvaluationTestCase input output) -> [input, output]
      _ -> []

-- | Haskell-specific test generator
-- Provides the complete Haskell implementation of the TestGenerator abstraction
haskellTestGenerator :: TestGenerator H.ModuleName
haskellTestGenerator = TestGenerator {
  testGenNamespacesForModule = namespacesForModule,
  testGenCreateCodec = haskellTestCodec,
  testGenGenerateTestFile = generateHaskellTestFile,
  testGenAggregatorFile = Just generateHaskellAggregatorSpec
}

-- | Generate an aggregator spec file that imports all generated test modules (Haskell/HSpec style)
generateHaskellAggregatorSpec :: FilePath -> [Module] -> (FilePath, String)
generateHaskellAggregatorSpec baseDir modules =
  let addSpecSuffix (Namespace ns) = Namespace (ns ++ "Spec")
      modulePaths = map (namespaceToModuleName . addSpecSuffix . addGenerationPrefix . moduleNamespace) modules
      imports = L.intercalate "\n" $ map (\m -> "import qualified " ++ m ++ " as " ++ sanitizeModuleName m) modulePaths
      specs = L.intercalate "\n    " $ map (\m -> sanitizeModuleName m ++ ".spec") modulePaths
      content = unlines [
        "-- Note: this is an automatically generated file. Do not edit.",
        "",
        "module Generation.Spec (spec) where",
        "",
        "import qualified Test.Hspec as H",
        imports,
        "",
        "spec :: H.Spec",
        "spec = do",
        "    " ++ specs
        ]
      filePath = FP.combine baseDir "Generation/Spec.hs"
  in (filePath, content)
  where
    sanitizeModuleName = map (\c -> if c == '.' then '_' else c)
    namespaceToModuleName (Namespace ns) =
      L.intercalate "." $ L.map capitalize (L.filter (not . null) $ Strings.splitOn "." ns)
    capitalize [] = []
    capitalize (x:xs) = toUpper x : xs
