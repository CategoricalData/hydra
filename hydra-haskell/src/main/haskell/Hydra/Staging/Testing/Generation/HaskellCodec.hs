{-# LANGUAGE OverloadedStrings #-}

module Hydra.Staging.Testing.Generation.HaskellCodec where

import Hydra.Kernel hiding (map)
import Hydra.Testing
import Hydra.Coders (LanguageName(..))
import Hydra.Staging.Testing.Generation.Transform (collectTestCases)
import Hydra.Staging.Testing.Generation.Generate (TestGenerator(..))
import qualified Hydra.Ext.Haskell.Coder as HaskellCoder
import Hydra.Ext.Haskell.Utils (namespacesForModule, sanitizeHaskellName)
import qualified Hydra.Ext.Haskell.Serde as HaskellSerde
import Hydra.Serialization (printExpr, parenthesize)
import qualified Hydra.Ext.Haskell.Ast as H
import qualified Hydra.Names as Names
import qualified Hydra.Util as Util
import qualified Hydra.Show.Core as ShowCore
import qualified Hydra.Formatting as Formatting
import qualified Hydra.Lib.Strings as Strings
import qualified Hydra.Lib.Lists as Lists

import qualified Data.Map as M
import qualified Data.List as L
import qualified Data.Set as S
import qualified Hydra.Rewriting as Rewriting
import Debug.Trace


termToHaskell :: Namespaces H.ModuleName -> Term -> Flow Graph String
termToHaskell namespaces term = (printExpr . parenthesize . HaskellSerde.expressionToExpr) <$>
  HaskellCoder.encodeTerm namespaces term

typeToHaskell :: Namespaces H.ModuleName -> Type -> Flow Graph String
typeToHaskell namespaces typ = (printExpr . parenthesize . HaskellSerde.typeToExpr) <$>
  HaskellCoder.encodeType namespaces typ

-- | Create a Haskell TestCodec that uses the real Haskell coder
haskellTestCodec :: Namespaces H.ModuleName -> TestCodec
haskellTestCodec namespaces = TestCodec {
    testCodecLanguage = LanguageName "haskell",
    testCodecFileExtension = FileExtension "hs",
    testCodecEncodeTerm = termToHaskell namespaces,
    testCodecEncodeType = typeToHaskell namespaces,
    testCodecFormatTestName = id,  -- Keep test names as-is
    testCodecFormatModuleName = namespaceToModuleName,
    testCodecTestCaseTemplate = haskellTestCaseTemplate,
    testCodecTestGroupTemplate = haskellTestGroupTemplate,
    testCodecModuleTemplate = haskellModuleTemplate,
    testCodecImportTemplate = haskellImportTemplate,
    testCodecFindImports = findHaskellImports namespaces}

-- Templates for Haskell test generation
haskellTestCaseTemplate :: String
haskellTestCaseTemplate = unlines [
  "  H.it {name} $ H.shouldBe",
  "    ({input})",
  "    ({output})"]

haskellTestGroupTemplate :: String
haskellTestGroupTemplate = "spec = H.describe {groupName} $ do"

haskellModuleTemplate :: String
haskellModuleTemplate = unlines [
  "-- " ++ warningAutoGeneratedFile,
  "",
  "module {moduleName} where",
  "",
  "{imports}",
  "",
  "spec :: H.Spec",
  "{testGroup}",
  "{testCases}"]

haskellImportTemplate :: String
haskellImportTemplate = "import qualified {namespace} as {alias}"

-- | Find necessary imports for Haskell based on referenced names
findHaskellImports :: Namespaces H.ModuleName -> S.Set Name -> [String]
findHaskellImports namespaces names = L.map makeImport (M.toList filteredMapping)
  where
    -- Filter out test module namespaces (hydra.test.*) which aren't in main library
    isTestNamespace (Namespace ns) = "hydra.test." `L.isPrefixOf` ns
    filteredMapping = M.filterWithKey (\ns _ -> not (isTestNamespace ns)) (namespacesMapping namespaces)
    makeImport (ns, alias) =
      "import qualified " ++ nsToModuleName ns ++ " as " ++ H.unModuleName alias
    nsToModuleName (Namespace ns) =
      Strings.intercalate "." $ Lists.map Formatting.capitalize (Strings.splitOn "." ns)

-- | Generic test file generation using a TestCodec
generateTestFileWithCodec :: TestCodec -> Module -> TestGroup -> Namespaces H.ModuleName -> Flow Graph (FilePath, String)
generateTestFileWithCodec codec testModule testGroup namespaces = do
  -- Perform inference so that we have a meaningful TypeContext later on
  g0 <- getState
  g <- inferGraphTypes g0
--  fail $ "graph elements: {" ++ (L.intercalate ", " $ fmap (unName . bindingName) (M.elems $ graphElements g)) ++ "}"

  infContext <- graphToInferenceContext g

  -- Generate test cases using the codec's encodeTerm
  testCases <- mapM (generateTestCaseWithCodec infContext namespaces codec) (collectTestCases testGroup)

  -- Build the complete test module
  let testModuleContent = buildTestModuleWithCodec codec testModule testGroup (concat testCases) namespaces

  -- Use the codec's file extension for the path
  -- Append "Spec" to the namespace for hspec-discover compatibility
  let FileExtension ext = testCodecFileExtension codec
  let Namespace ns = moduleNamespace testModule
  let specNs = Namespace (ns ++ "Spec")
  let filePath = Names.namespaceToFilePath Util.CaseConventionPascal
                   (FileExtension ext)
                   specNs

  return (filePath, testModuleContent)

-- | Generate a single test case using a TestCodec
generateTestCaseWithCodec :: InferenceContext -> Namespaces H.ModuleName -> TestCodec -> TestCaseWithMetadata -> Flow Graph [String]
generateTestCaseWithCodec infContext namespaces codec (TestCaseWithMetadata name tcase _ _) = case tcase of
  TestCaseDelegatedEvaluation (DelegatedEvaluationTestCase input output) -> do

    inputCode <- testCodecEncodeTerm codec input
    outputCode <- testCodecEncodeTerm codec output

    -- Format the test name using the codec
    let formattedName = testCodecFormatTestName codec name
        -- Helper to indent continuation lines to maintain alignment with opening paren
        indentLines n s = L.intercalate ("\n" ++ replicate n ' ') (L.lines s)
        -- The opening paren is at column 4, so indent continuation lines by 4 spaces
        indentedInputCode = indentLines 4 inputCode
        indentedOutputCode = indentLines 4 outputCode

    -- Check if output needs a type annotation (only when BOTH input and output are polymorphic)
    graph <- getState
    typeAnnotation <- generateTypeAnnotationFor infContext namespaces input output
    let (finalInputCode, finalOutputCode) = case typeAnnotation of
          Just anno -> (indentedInputCode, indentedOutputCode ++ anno)
          Nothing -> (indentedInputCode, indentedOutputCode)

    return [
      "  H.it " ++ show formattedName ++ " $ H.shouldBe",
      "    (" ++ finalInputCode ++ ")",
      "    (" ++ finalOutputCode ++ ")"]

  _ -> return []  -- Skip non-delegated tests (shouldn't happen after transform)

-- | Generate a type annotation for polymorphic output values
-- Only adds annotations when output is trivially polymorphic (empty list, Nothing)
-- where GHC has no concrete values to guide type inference.
generateTypeAnnotationFor :: InferenceContext -> Namespaces H.ModuleName -> Term -> Term -> Flow Graph (Maybe String)
generateTypeAnnotationFor infContext namespaces inputTerm outputTerm = do
    (_, ts) <- inferTypeOf infContext inputTerm
    let vars = S.toList $ freeVariablesInType $ typeSchemeType ts
    let subst = TypeSubst $ M.fromList $ fmap (\v -> (v, TypeLiteral LiteralTypeString)) vars
--    let vars = typeSchemeVariables ts
    if L.null vars
      then return Nothing
      else do
        sig <- typeToHaskell $ substInType subst $ typeSchemeType ts
        return $ Just $ " :: " ++ sig
  where
    typeToHaskell typ = do
       htype <- HaskellCoder.encodeType namespaces typ
       return $ printExpr $ HaskellSerde.typeToExpr htype

-- | Check if a term is trivially polymorphic (no concrete values to guide type inference)
isTriviallyPolymorphic :: Term -> Bool
isTriviallyPolymorphic term = case term of
  TermList [] -> True  -- Empty list
  TermMaybe Nothing -> True  -- Nothing value
  TermApplication app ->  -- Check if all parts are polymorphic
    isTriviallyPolymorphic (applicationFunction app) &&
    isTriviallyPolymorphic (applicationArgument app)
  _ -> False

-- | Build the complete test module using a TestCodec
buildTestModuleWithCodec :: TestCodec -> Module -> TestGroup -> [String] -> Namespaces H.ModuleName -> String
buildTestModuleWithCodec codec testModule testGroup testCases namespaces = header ++ testBody ++ "\n"
  where
    -- Append "Spec" to module name for hspec-discover compatibility
    Namespace ns = moduleNamespace testModule
    specNs = Namespace (ns ++ "Spec")
    moduleNameString = testCodecFormatModuleName codec specNs
    groupName = testGroupName testGroup

    -- Use the codec's findImports to determine necessary imports
    -- For now, we'll pass an empty set since we're not tracking names yet
    -- TODO: collect names from test cases
    domainImports = testCodecFindImports codec S.empty

    -- Standard imports that are always needed for Haskell
    standardImports = [
      "import Hydra.Kernel",
      "import qualified Test.Hspec as H"]

    allImports = standardImports ++ domainImports

    -- Debug comments showing namespace configuration
    debugComments = [
        "-- DEBUG: Focus namespace = " ++ show (namespacesFocus namespaces),
        "-- DEBUG: Namespace mappings:",
        "-- " ++ show (M.toList $ namespacesMapping namespaces)
      ]

    header = unlines ([
        "-- " ++ warningAutoGeneratedFile,
        ""
      ] ++ debugComments ++ [
        "",
        "module " ++ moduleNameString ++ " where",
        ""
      ] ++ allImports ++ [
        "",
        "spec :: H.Spec",
        "spec = H.describe " ++ show groupName ++ " $ do"
      ])
    testBody = L.intercalate "\n" testCases

-- | Convert namespace to Haskell module name
-- Uses the same logic as the Haskell coder's importName function
namespaceToModuleName :: Namespace -> String
namespaceToModuleName (Namespace ns) =
  Strings.intercalate "." $ Lists.map Formatting.capitalize (Strings.splitOn "." ns)

-- | Generate generation test file for a test group using the Haskell codec
generateHaskellTestFile :: Module -> TestGroup -> Flow Graph (FilePath, String)
generateHaskellTestFile testModule testGroup = do
  -- Build proper namespaces that include all primitives referenced in test terms
  namespaces <- buildNamespacesForTestGroup testModule testGroup

  -- Generate test file using the codec
  generateTestFileWithCodec (haskellTestCodec namespaces) testModule testGroup namespaces
  where
    buildNamespacesForTestGroup mod tgroup = do
      let testCases = collectTestCases tgroup
          testTerms = concatMap extractTestTerms testCases
          testBindings = zipWith (\i term -> Binding (Name $ "_test_" ++ show i) term Nothing) ([0..] :: [Integer]) testTerms
          tempModule = mod { moduleElements = testBindings }
      namespacesForModule tempModule
    extractTestTerms (TestCaseWithMetadata _ tcase _ _) = case tcase of
      TestCaseDelegatedEvaluation (DelegatedEvaluationTestCase input output) -> [input, output]
      _ -> []

-- | Haskell-specific test generator
-- Provides the complete Haskell implementation of the TestGenerator abstraction
haskellTestGenerator :: TestGenerator H.ModuleName
haskellTestGenerator = TestGenerator {
  testGenNamespacesForModule = namespacesForModule,
  testGenCreateCodec = haskellTestCodec,
  testGenGenerateTestFile = generateHaskellTestFile
}
