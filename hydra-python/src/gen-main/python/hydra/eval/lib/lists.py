# Note: this is an automatically generated file. Do not edit.

r"""Evaluation-level implementations of List functions for the Hydra interpreter."""

from __future__ import annotations
from hydra.dsl.python import Nothing, frozenlist
from typing import TypeVar, cast
import hydra.compute
import hydra.core
import hydra.extract.core
import hydra.graph
import hydra.lib.flows
import hydra.lib.lists
import hydra.lib.pairs

T0 = TypeVar("T0")

def apply(funs_term: hydra.core.Term, args_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly applicative apply for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(funs_term), (lambda funs: hydra.lib.flows.bind(hydra.extract.core.list(args_term), (lambda arguments: (apply_one := (lambda f: hydra.lib.lists.map((lambda arg: cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(f, arg)))), arguments)), hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermList(hydra.lib.lists.concat(hydra.lib.lists.map(apply_one, funs))))))[1]))))

def bind(list_term: hydra.core.Term, fun_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly monadic bind for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term), (lambda elements: hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.concat"))))), cast(hydra.core.Term, hydra.core.TermList(hydra.lib.lists.map((lambda el: cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(fun_term, el)))), elements)))))))))

def drop_while(pred_term: hydra.core.Term, list_term: hydra.core.Term) -> hydra.compute.Flow[T0, hydra.core.Term]:
    return hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.second"))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.span"))))), pred_term))), list_term)))))))

def filter(pred_term: hydra.core.Term, list_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly filter for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term), (lambda elements: hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.concat"))))), cast(hydra.core.Term, hydra.core.TermList(hydra.lib.lists.map((lambda el: cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.logic.ifElse"))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(pred_term, el)))))), cast(hydra.core.Term, hydra.core.TermList(hydra.lib.lists.pure(el)))))), cast(hydra.core.Term, hydra.core.TermList(())))))), elements)))))))))

def foldl(fun_term: hydra.core.Term, init_term: hydra.core.Term, list_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly left fold for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term), (lambda elements: hydra.lib.flows.pure(hydra.lib.lists.foldl((lambda acc, el: cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(fun_term, acc))), el)))), init_term, elements))))

def map(fun_term: hydra.core.Term, list_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly map for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term), (lambda elements: hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermList(hydra.lib.lists.reverse(hydra.lib.lists.foldl((lambda acc, el: hydra.lib.lists.cons(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(fun_term, el))), acc)), (), elements)))))))

def sort_on(proj_term: hydra.core.Term, list_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly sortOn for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term), (lambda elements: hydra.lib.flows.pure(hydra.lib.lists.foldl((lambda sorted, x: (split_result := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.span"))))), cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionLambda(hydra.core.Lambda(hydra.core.Name("y"), Nothing(), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.equality.lte"))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(proj_term, cast(hydra.core.Term, hydra.core.TermVariable(hydra.core.Name("y"))))))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(proj_term, x)))))))))))))), sorted))), before := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.first"))))), split_result))), after := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.second"))))), split_result))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.concat2"))))), before))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.cons"))))), x))), after)))))))[3]), cast(hydra.core.Term, hydra.core.TermList(())), elements))))

def span(pred_term: hydra.core.Term, list_term: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly span for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term), (lambda elements: (initial_state := cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermLiteral(cast(hydra.core.Literal, hydra.core.LiteralBoolean(True)))), cast(hydra.core.Term, hydra.core.TermList(()))))), cast(hydra.core.Term, hydra.core.TermList(()))))), final_state := hydra.lib.lists.foldl((lambda acc, el: (taking_left := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.first"))))), acc))), right := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.second"))))), acc))), taking := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.first"))))), taking_left))), left := cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.second"))))), taking_left))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.logic.ifElse"))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.logic.and"))))), taking))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(pred_term, el))))))))), cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermLiteral(cast(hydra.core.Literal, hydra.core.LiteralBoolean(True)))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.concat2"))))), left))), cast(hydra.core.Term, hydra.core.TermList((el,))))))))), right)))))), cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermLiteral(cast(hydra.core.Literal, hydra.core.LiteralBoolean(False)))), left))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.lists.concat2"))))), right))), cast(hydra.core.Term, hydra.core.TermList((el,)))))))))))))[4]), initial_state, elements), hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermPair((cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.second"))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.first"))))), final_state)))))), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermFunction(cast(hydra.core.Function, hydra.core.FunctionPrimitive(hydra.core.Name("hydra.lib.pairs.second"))))), final_state))))))))[2]))

def zip_with(fun_term: hydra.core.Term, list_term1: hydra.core.Term, list_term2: hydra.core.Term) -> hydra.compute.Flow[hydra.graph.Graph, hydra.core.Term]:
    r"""Interpreter-friendly zipWith for List terms."""
    
    return hydra.lib.flows.bind(hydra.extract.core.list(list_term1), (lambda elements1: hydra.lib.flows.bind(hydra.extract.core.list(list_term2), (lambda elements2: hydra.lib.flows.pure(cast(hydra.core.Term, hydra.core.TermList(hydra.lib.lists.map((lambda p: (a := hydra.lib.pairs.first(p), b := hydra.lib.pairs.second(p), cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(cast(hydra.core.Term, hydra.core.TermApplication(hydra.core.Application(fun_term, a))), b))))[2]), hydra.lib.lists.zip(elements1, elements2)))))))))
