"""A set of types which supplement hydra/core with variants and accessors."""

from __future__ import annotations
from dataclasses import dataclass
from hydra.dsl.types import Variant
from typing import Generic, NewType, TypeVar
import hydra.core

A = TypeVar("A")
B = TypeVar("B")

class EitherLeft(Variant[A]): ...

class EitherRight(Variant[B]): ...

# A disjoint union between a 'left' type and a 'right' type.
type Either = EitherLeft | EitherRight

class EliminationVariantList(Variant[None]): ...

class EliminationVariantOptional(Variant[None]): ...

class EliminationVariantProduct(Variant[None]): ...

class EliminationVariantRecord(Variant[None]): ...

class EliminationVariantUnion(Variant[None]): ...

class EliminationVariantWrap(Variant[None]): ...

# The identifier of an elimination constructor.
type EliminationVariant = EliminationVariantList | EliminationVariantOptional | EliminationVariantProduct | EliminationVariantRecord | EliminationVariantUnion | EliminationVariantWrap

class FunctionVariantElimination(Variant[None]): ...

class FunctionVariantLambda(Variant[None]): ...

class FunctionVariantPrimitive(Variant[None]): ...

# The identifier of a function constructor.
type FunctionVariant = FunctionVariantElimination | FunctionVariantLambda | FunctionVariantPrimitive

class LiteralVariantBinary(Variant[None]): ...

class LiteralVariantBoolean(Variant[None]): ...

class LiteralVariantFloat(Variant[None]): ...

class LiteralVariantInteger(Variant[None]): ...

class LiteralVariantString(Variant[None]): ...

# The identifier of a literal constructor.
type LiteralVariant = LiteralVariantBinary | LiteralVariantBoolean | LiteralVariantFloat | LiteralVariantInteger | LiteralVariantString

class PrecisionArbitrary(Variant[None]): ...

class PrecisionBits(Variant[int]): ...

# Numeric precision: arbitrary precision, or precision to a specified number of bits.
type Precision = PrecisionArbitrary | PrecisionBits

class TermAccessorAnnotatedSubject(Variant[None]): ...

class TermAccessorApplicationFunction(Variant[None]): ...

class TermAccessorApplicationArgument(Variant[None]): ...

class TermAccessorLambdaBody(Variant[None]): ...

class TermAccessorListFold(Variant[None]): ...

class TermAccessorOptionalCasesNothing(Variant[None]): ...

class TermAccessorOptionalCasesJust(Variant[None]): ...

class TermAccessorUnionCasesDefault(Variant[None]): ...

class TermAccessorUnionCasesBranch(Variant[hydra.core.Name]):
    """A unique identifier in some context; a string-valued key."""

class TermAccessorLetEnvironment(Variant[None]): ...

class TermAccessorLetBinding(Variant[hydra.core.Name]):
    """A unique identifier in some context; a string-valued key."""

class TermAccessorListElement(Variant[int]): ...

class TermAccessorMapKey(Variant[int]): ...

class TermAccessorMapValue(Variant[int]): ...

class TermAccessorOptionalTerm(Variant[None]): ...

class TermAccessorProductTerm(Variant[int]): ...

class TermAccessorRecordField(Variant[hydra.core.Name]):
    """A unique identifier in some context; a string-valued key."""

class TermAccessorSetElement(Variant[int]): ...

class TermAccessorSumTerm(Variant[None]): ...

class TermAccessorTypeAbstractionBody(Variant[None]): ...

class TermAccessorTypeApplicationTerm(Variant[None]): ...

class TermAccessorTypedTerm(Variant[None]): ...

class TermAccessorInjectionTerm(Variant[None]): ...

class TermAccessorWrappedTerm(Variant[None]): ...

# A function which maps from a term to a particular immediate subterm.
type TermAccessor = TermAccessorAnnotatedSubject | TermAccessorApplicationFunction | TermAccessorApplicationArgument | TermAccessorLambdaBody | TermAccessorListFold | TermAccessorOptionalCasesNothing | TermAccessorOptionalCasesJust | TermAccessorUnionCasesDefault | TermAccessorUnionCasesBranch | TermAccessorLetEnvironment | TermAccessorLetBinding | TermAccessorListElement | TermAccessorMapKey | TermAccessorMapValue | TermAccessorOptionalTerm | TermAccessorProductTerm | TermAccessorRecordField | TermAccessorSetElement | TermAccessorSumTerm | TermAccessorTypeAbstractionBody | TermAccessorTypeApplicationTerm | TermAccessorTypedTerm | TermAccessorInjectionTerm | TermAccessorWrappedTerm

class TermVariantAnnotated(Variant[None]): ...

class TermVariantApplication(Variant[None]): ...

class TermVariantFunction(Variant[None]): ...

class TermVariantLet(Variant[None]): ...

class TermVariantList(Variant[None]): ...

class TermVariantLiteral(Variant[None]): ...

class TermVariantMap(Variant[None]): ...

class TermVariantOptional(Variant[None]): ...

class TermVariantProduct(Variant[None]): ...

class TermVariantRecord(Variant[None]): ...

class TermVariantSet(Variant[None]): ...

class TermVariantSum(Variant[None]): ...

class TermVariantTypeAbstraction(Variant[None]): ...

class TermVariantTypeApplication(Variant[None]): ...

class TermVariantTyped(Variant[None]): ...

class TermVariantUnion(Variant[None]): ...

class TermVariantVariable(Variant[None]): ...

class TermVariantWrap(Variant[None]): ...

# The identifier of a term expression constructor.
type TermVariant = TermVariantAnnotated | TermVariantApplication | TermVariantFunction | TermVariantLet | TermVariantList | TermVariantLiteral | TermVariantMap | TermVariantOptional | TermVariantProduct | TermVariantRecord | TermVariantSet | TermVariantSum | TermVariantTypeAbstraction | TermVariantTypeApplication | TermVariantTyped | TermVariantUnion | TermVariantVariable | TermVariantWrap

@dataclass
class TypeConstraint:
    """An assertion that two types can be unified into a single type."""
    
    left: hydra.core.Type
    right: hydra.core.Type
    context: str | None

class TypeVariantAnnotated(Variant[None]): ...

class TypeVariantApplication(Variant[None]): ...

class TypeVariantFunction(Variant[None]): ...

class TypeVariantLambda(Variant[None]): ...

class TypeVariantList(Variant[None]): ...

class TypeVariantLiteral(Variant[None]): ...

class TypeVariantMap(Variant[None]): ...

class TypeVariantOptional(Variant[None]): ...

class TypeVariantProduct(Variant[None]): ...

class TypeVariantRecord(Variant[None]): ...

class TypeVariantSet(Variant[None]): ...

class TypeVariantSum(Variant[None]): ...

class TypeVariantUnion(Variant[None]): ...

class TypeVariantVariable(Variant[None]): ...

class TypeVariantWrap(Variant[None]): ...

# The identifier of a type constructor.
type TypeVariant = TypeVariantAnnotated | TypeVariantApplication | TypeVariantFunction | TypeVariantLambda | TypeVariantList | TypeVariantLiteral | TypeVariantMap | TypeVariantOptional | TypeVariantProduct | TypeVariantRecord | TypeVariantSet | TypeVariantSum | TypeVariantUnion | TypeVariantVariable | TypeVariantWrap